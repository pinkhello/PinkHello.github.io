<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>k8s on pinkhello</title><link>https://pinkhello.cc/tags/k8s/</link><description>Recent content in k8s on pinkhello</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>pinkhello</copyright><lastBuildDate>Tue, 18 May 2021 08:00:00 +0800</lastBuildDate><atom:link href="https://pinkhello.cc/tags/k8s/index.xml" rel="self" type="application/rss+xml"/><item><title>回望K8S 持久化存储</title><link>https://pinkhello.cc/posts/22-%E5%9B%9E%E6%9C%9Bk8s-%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/</link><pubDate>Tue, 18 May 2021 08:00:00 +0800</pubDate><guid>https://pinkhello.cc/posts/22-%E5%9B%9E%E6%9C%9Bk8s-%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/</guid><description>PV、PVC、StorageClass 说的啥？ PV: 持久化存储数据卷，这个 API 主要定义的是一个持久化存储在宿主机上的一个目录。一般由运维人员进行定义，比如定义一个 NFS 类型的 PV
apiVersion: v1 kind: PersistentVolume metadata: name: nfs spec: storageClassName: manual capacity: storage: 1Gi accessModes: - ReadWriteMany nfs: server: 10.244.1.5 path: &amp;#34;/&amp;#34; PVC: POD 所希望使用的持久化存储的属性. 比如 Volume 的存储大小、可读写权限等. PVC 一般由开发人员创建、或者由 PVC模板的方式成为StatefulSet的一部分，由StatefulSet控制器负责创建带编号的PVC.
# 创建一个 1 GB 大小的PVC --- apiVersion: v1 kind: PersistentVolumeClaim metadata: name: nfs spec: accessModes: - ReadWriteMany storageClassName: manual resources: requests: storage: 1Gi ... 用户创建的PVC要真正的被容器使用的化，需要于心和某个符合条件的PV进行绑定：
第一个条件，PV 和 PVC 的 spec 字段。例如: PV 的存储(storage)大小就必须满足 PVC 的要求 第二个条件，PV 和 PVC 的 storageClassName 字段名称必须一样。 下面是去使用这个PVC</description></item><item><title>回望K8S 容器编排与Kubernetes作业管理</title><link>https://pinkhello.cc/posts/20-%E5%9B%9E%E6%9C%9Bk8s-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8Ekubernetes%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 17 May 2021 08:00:00 +0800</pubDate><guid>https://pinkhello.cc/posts/20-%E5%9B%9E%E6%9C%9Bk8s-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8Ekubernetes%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86/</guid><description>Pod pod 是 Kubernetes 项目的最小的 API 对象，原子调度单位.
假设 &amp;ldquo;容器的本质是进程&amp;rdquo;，容器镜像就是 exe 安装包, kubernetes 是操作系统
Pod 最重要的一个事实是一个逻辑概念。它对于 Kubernetes 最核心的意义是 容器设计模式。Kubernetes 真正处理的还是宿主机上操作系统上的 Linux 容器的 Namespace 和 Cgroups，而不是一个所谓的 Pod 边界和隔离环境。
Pod 其实是一组共享了某些资源的容器。Pod 里面所有的容器，共享的同一个 Network Namespace，并且可以声明共享同一个 Volume.
Kubernetes 项目内部，Pod 实现需要使用一个中间容器，这个容器叫做 Infra 容器，在 Pod 中，Infra 容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过 Join Network Namespace 的方式，与 Infra 容器关联在一起。
sidecar 典型的例子：WAR 包和 Web 服务器 POD后，将 WAR 包和 Tomcat 分别做成镜像，可以把他们容器结合在一起
--- apiVersion: v1 kind: Pod metadata: name: javaweb-2 spec: # 启动后做了一件事 把应用的WAR包拷贝到 /app目录中，后退出 initContainers: - image: sample-war:v2 name: war command: [&amp;#34;cp&amp;#34;, &amp;#34;/sample.</description></item><item><title>回望K8S Kubernetes拼图</title><link>https://pinkhello.cc/posts/19-%E5%9B%9E%E6%9C%9Bk8s-kubernetes%E6%8B%BC%E5%9B%BE/</link><pubDate>Sun, 16 May 2021 08:00:00 +0800</pubDate><guid>https://pinkhello.cc/posts/19-%E5%9B%9E%E6%9C%9Bk8s-kubernetes%E6%8B%BC%E5%9B%BE/</guid><description>kubernetes 安装 all 节点安装 Docker 和 Kubeadm 所有节点 root 用户下操作
&amp;gt; curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add - &amp;gt; cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/apt/sources.list.d/kubernetes.list deb http://apt.kubernetes.io/ kubernetes-xenial main EOF &amp;gt; apt-get update # 这一步安装的时候 kubeadm 和 kubelet、kubectl、kubernetes-cni 都会自动安装完毕 &amp;gt; apt-get install -y docker.io kubeadm 提示：如果 apt.kubernetes.io 因为网络问题访问不到，可以换成中科大的 Ubuntu 镜像源 deb http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial main。
部署 Kubernetes Master 声明一个 kubeadm.yaml
--- apiVersion: kubeadm.k8s.io/v1alpha1 kind: MasterConfiguration controllerManagerExtraArgs: # 配置了自定义自动水平扩展 horizontal-pod-autoscaler-use-rest-clients: &amp;#34;true&amp;#34; horizontal-pod-autoscaler-sync-period: &amp;#34;10s&amp;#34; node-monitor-grace-period: &amp;#34;10s&amp;#34; apiServerExtraArgs: runtime-config: &amp;#34;api/all=true&amp;#34; # kubeadm 部署的 kubernetes 的版本 kubernetesVersion: &amp;#34;stable-1.</description></item><item><title>回望K8S 白话容器</title><link>https://pinkhello.cc/posts/18-%E5%9B%9E%E6%9C%9Bk8s-%E7%99%BD%E8%AF%9D%E5%AE%B9%E5%99%A8/</link><pubDate>Sat, 15 May 2021 08:00:00 +0800</pubDate><guid>https://pinkhello.cc/posts/18-%E5%9B%9E%E6%9C%9Bk8s-%E7%99%BD%E8%AF%9D%E5%AE%B9%E5%99%A8/</guid><description>进程开启 容器, 到底是什么? 前面提出: 容器是一种沙盒技术. 就是一个集装箱, 把应用装起来的技术. 这样, 应用与应用之间有了边界不至于互相干扰; 有了这些集装箱, 也方便搬来搬去.
码农都知道可执行的二进制文件是代码的可执行镜像(executable image). 一旦程序执行起来, 内存数据、寄存器的值、堆栈的指令、打开的文件等这些集合汇集成一个程序的计算机执行环境总和: 进程.
进程: 静态表现是程序, 动态表现计算机的数据和状态的总和。
容器的核心功能, 就是通过约束和修改进程的动态表现, 从而为其创造一个&amp;quot;边界&amp;quot;.
Cgroups 技术 制造约束的主要手段 Namespace 技术 修改进程视图的主要方法 docker run , -it 告诉 Docker 启动容器后, 需要分配一个文本输入/输出环境, 也就是 TTY, 跟容器的标准输入相关联, 这样我们就可以和这个Docker容器进行交互了。而 /bin/sh 就是我们在 Docker 容器里运行的程序.
&amp;gt; docker run -it busybox /bin/sh / # 帮我启动一个容器, 在容器里执行 /bin/sh, 并且给我分配一个命令行终端跟这个容器进行交互, 在这个执行环境下可以完全执行LINUX命令,且与宿主机完全隔离在不同的世界中.
Docker对被隔离应用的进程空间做了手脚, 使得这些进程只能看到重新计算的进程编号, 可是实际上, 他们在宿主机的操作系统里, 还是原来的第N号进程. 这种技术就是Linux内部的Namespace机制。
Namespace 的使用方式也非常有意思：它其实只是 Linux 创建新进程的一个可选参数。我们知道，在 Linux 系统中创建线程的系统调用是 clone()，比如：</description></item><item><title>回望K8S 小鲸鱼容器技术</title><link>https://pinkhello.cc/posts/17-%E5%9B%9E%E6%9C%9Bk8s-%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/</link><pubDate>Fri, 14 May 2021 08:00:00 +0800</pubDate><guid>https://pinkhello.cc/posts/17-%E5%9B%9E%E6%9C%9Bk8s-%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/</guid><description>什么是容器 在容器之前, 火爆云计算市场的是 PAAS, PAAS已经深入人心. 那时候突然有一家公司 dotCloud 剑走偏锋, 直接开源出了 Docker 项目，并且直接面向的社区。 这样的做法直接将当时的PAAS流主要公司打的屁滚尿流。
回头看, PAAS 最核心的是隔离环境,或者叫 沙盒,在我看来也就是 容器. 而 Docker 项目和 Cloud Foundry 的容器没有太大的不同,但是它为什么能针对 PAAS进行了一场快速的闪电战呢？
对的, 就是 Docker 镜像, 这个小小的创新, 迅速改变了云计算的发展轨迹! Docker 镜像解决的是 打包 问题。也许有人说Docker 镜像就是一个压缩包。但是就是这个压缩包包含了完整的操作系统文件和目录, 包含了整个应用所需要的依赖，一包在手, 你可以轻易的运行你的沙盒,并且本地环境与云端环境高度一致（这是最宝贵的）。
Docker给PAAS进行了致命打击, 提供了便利的打包机制, 面向后端开发者来说, 屏蔽了机器、内核等技术细节, 避免了在不同环境间的差异引入的试错成本。是一次解放生产力的革命。当然很多开发者用脚投票, 了结了PAAS时代。
Docker 三大利器 Docker项目的高调开源, 解决了打包和发布困扰运维的技术难题，同时它也第一次纯后端的概念通过友好的设计和封装交付到了开发者的手里。 Swarm,Docker是创建和启停容器的工具,那么Swarm是为了向平台化发展而提出的。它提供了完整的整体对外提供集群管理功能,它的亮点是完全使用Docker原本的管理容器的API来完成集群管理 # Swarm多机环境下，指令会被Swarm拦截处理，后面通过调度算法找到合适的Docker Daemon运行 docker run -H &amp;#34;Swarm集群API&amp;#34; &amp;#34;我的容器&amp;#34; Compose(Fig)项目, 这是第一次在开发者面前提出 容器编排(Container Orchestration)概念。 应用容器 A, 数据库容器B, 负载均衡容器C, Compose 允许 A、B、C 三个容器定义在配置文件中, 并指定关联关系. 只需要执行 (fig/docker-compose up)</description></item><item><title>记一次docker日志磁盘告警问题</title><link>https://pinkhello.cc/posts/15-%E8%AE%B0%E4%B8%80%E6%AC%A1docker%E6%97%A5%E5%BF%97%E7%A3%81%E7%9B%98%E5%91%8A%E8%AD%A6%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 10 May 2021 08:00:00 +0800</pubDate><guid>https://pinkhello.cc/posts/15-%E8%AE%B0%E4%B8%80%E6%AC%A1docker%E6%97%A5%E5%BF%97%E7%A3%81%E7%9B%98%E5%91%8A%E8%AD%A6%E9%97%AE%E9%A2%98/</guid><description>前景 今日，我正在开开心心的刷着JFX的Coding中，突然线上报警群中爆了个炸弹，EC2磁盘超过80%。
处理过程 解决问题姿势就位：
赶紧开机 ==》 ❤️中万匹🦙奔腾而过 ❤️中MMP
默默的通过跳板机进入目标机器
不管三七二十一,执行查看磁盘占用大小，我的乖乖，占用确实超过了87%了，一下子暴涨的
# 查看磁盘占用大小 &amp;gt; sudo df -h # 查看当前目录总量 &amp;gt; sudo du -sh 开始定位具体哪个文件或者目录占用这么大,跑到根目录下。 # 查看当前目录下一级子文件和子目录占用的磁盘容量 &amp;gt; sudo du -lh --max-depth=1 一开始猜想可能是docker容器的日志占用大，上面执行后，还真 TM 是 /var/lib/docker/containers 目录占用 42G 开始查看是哪个容器占用的这么大的空间 # 查看 containers 日志目录排序 &amp;gt; sudo du -d1 -h /var/lib/docker/containers | sort -h # 查看具体的哪个日志文件大 &amp;gt; sudo find /var/lib/docker/containers -name *.log 当然这个配图是我清理之后的 定位到最大的文件，一顿操作 # 清空比较大的日志文件 &amp;gt; sudo sh -c &amp;#34;cat /dev/null &amp;gt; ${log_file}&amp;#34; 思考 上面的方式是一种方式解决【临时】 # 查看 docker 的 Logging Driver &amp;gt; docker info | grep &amp;#39;Logging Driver&amp;#39; 如何彻底解决这个问题： 写个shell脚本 使用 crontab 定期执行清理 #!</description></item></channel></rss>