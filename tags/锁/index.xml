<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>锁 on pinkhello</title><link>https://pinkhello.cc/tags/%E9%94%81/</link><description>Recent content in 锁 on pinkhello</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>pinkhello</copyright><lastBuildDate>Wed, 30 Mar 2022 00:07:36 +0800</lastBuildDate><atom:link href="https://pinkhello.cc/tags/%E9%94%81/index.xml" rel="self" type="application/rss+xml"/><item><title>rand库锁竞争优化</title><link>https://pinkhello.cc/posts/go-rand/</link><pubDate>Wed, 30 Mar 2022 00:07:36 +0800</pubDate><guid>https://pinkhello.cc/posts/go-rand/</guid><description>前言 今天，在写随机数的生成的时候，好奇 rand 库在 golang 的实现，就翻进去看一眼的。rand.go#293 代码
var globalRand = New(&amp;amp;lockedSource{src: NewSource(1).(*rngSource)}) 竟然是全局共享的一个 全局的 globalRand 的 对象。可以猜想到在多 goroutine 下，性能应该比较差，存在竞争的情况。
验证 随机验证一下, 验证一下
第一种情况，就是普通的并发情况下使用默认的 rand 库。使其共用一个 globalRand 对象。 func BenchmarkGlobalRand_test(b *testing.B) { b.RunParallel(func(p *testing.PB) { for p.Next() { rand.Intn(200) } }) } 输出
BenchmarkGlobalRand_test BenchmarkGlobalRand_test-8 16704190 72.53 ns/op 0 B/op 0 allocs/op BenchmarkGlobalRand_test-8 17005326 68.90 ns/op 0 B/op 0 allocs/op BenchmarkGlobalRand_test-8 17651659 66.54 ns/op 0 B/op 0 allocs/op BenchmarkGlobalRand_test-8 17879901 68.07 ns/op 0 B/op 0 allocs/op 第二种情况，在每个 goroutine 内创建一个 rand 对象，达到不共享的效果 func BenchmarkCustomRand_test(b *testing.</description></item></channel></rss>