<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Grpc on pinkhello</title><link>https://pinkhello.cc/tags/grpc/</link><description>Recent content in Grpc on pinkhello</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>pinkhello</copyright><lastBuildDate>Fri, 01 Oct 2021 10:04:00 +0800</lastBuildDate><atom:link href="https://pinkhello.cc/tags/grpc/index.xml" rel="self" type="application/rss+xml"/><item><title>探秘负载均衡</title><link>https://pinkhello.cc/posts/36-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%80%9D%E8%80%83/</link><pubDate>Fri, 01 Oct 2021 10:04:00 +0800</pubDate><guid>https://pinkhello.cc/posts/36-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%80%9D%E8%80%83/</guid><description>前言 今天是国庆的第3天，在此恭祝小哥哥和小姐姐们⛱️节日快乐！ 微信朋友圈🀄️全部是 旅途ING。
对于我这种社交尴尬者，⛱️度假最好的方式还是学习。
今日带来了 自己对于负载均衡(load balance)的学习。
度假最好的方式是学习 GRPC在负载均衡的设计: Load-balancing.md
为什么要负载均衡 在如今的互联网领域，对于数据的大爆发，高频的请求，对于提供服务的企业来说是不小的IT资源开销。为了解决资源中的负载分配，并且使得资源的利用率达到最大。出现了负载均衡，主要为了解决 高并发 和 高可用。
负载均衡的实现方式有：软件 和 硬件。这次我学习的主是软件方式。
负载均衡的算法 轮询( Round Robin ) &amp;amp; 加权轮询( Weight Round Robin ) : 随机 &amp;amp; 加权随机 最少连接( Last Connections ) : 通过将流量引导到第一个可用服务器然后将该服务器移动到队列底部来轮换服务器，当服务器具有相同的规格并且没有很多持久连接时最有用。 哈希( Hash ) eg: ip hash 一致性哈希( Consistent Hash ) eg: request_url 一致性哈希 最少响应时间 : 将流量定向到活动连接最少且平均响应时间最短的服务器。 常用的负载均衡手段 Load-balancing.md 已经介绍了以下几种
代理模式 代理模式需要可靠的并且能报告负载到负载均衡的系统的客户端，这种需要额外的资源来处理、并且负载均衡系统包含了每个RPC请求和响应的副本，增加了服务延迟
重客户端模式 这种方式、是绝大部分负载均衡的逻辑放置在客户端。( 可以从列表重选择服务器的负载均衡策略(循环、随机等)，服务器列表要么配置的、要么由其他服务提供、举个例子：比如 kafka、pulsar、redis 等等集群模式的客户端 ) 这种模式需要已多种语言的方式提供负载均衡策略、这种增加了客户端代码的复杂性。
外部负载均衡模式 (重服务端 轻客户端) 客户端保持简单、并且可以非常简单可移植。实现用于服务器选择的著名算法。复杂的负载平衡算法由负载均衡器提供，客户端仅仅需要从负载均衡器提供的配置和服务器列表里面选择，并向它们发送客户端的请求。负载均衡器需要从这些服务器列表中选取出健康负载的服务器和剔出不可用服务器。在负载均衡器做出选举和其他决策的时候需要通知到客户端做更新。负载均衡器可以从后端服务中收集负载和健康信息。</description></item></channel></rss>