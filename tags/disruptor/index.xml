<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Disruptor on pinkhello</title><link>https://pinkhello.cc/tags/disruptor/</link><description>Recent content in Disruptor on pinkhello</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>pinkhello</copyright><lastBuildDate>Mon, 15 Mar 2021 08:00:00 +0800</lastBuildDate><atom:link href="https://pinkhello.cc/tags/disruptor/index.xml" rel="self" type="application/rss+xml"/><item><title>高性能队列Disruptor</title><link>https://pinkhello.cc/posts/06-%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97disruptor/</link><pubDate>Mon, 15 Mar 2021 08:00:00 +0800</pubDate><guid>https://pinkhello.cc/posts/06-%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97disruptor/</guid><description>背景 Disruptor 是 外汇交易公司LMAX开发的高性能队列、研发是为了解决内存队列延迟问题。 Disruptor 一般用于线程间的消息传递。 Disruptor GitHub 地址
Disruptor 介绍 理解 Disruptor 最好的方式，选择一个最接近熟悉的样本进行比较。在这个前提下，可以选择 Java 中的 BlockingQueue. 和队列相似，Disruptor 也是在同一个进程中不同的线程之间进行传递数据的（例如消息或者事件），同时 Disruptor 提供了一些将关键功能和队列分开的特性：
向消费者发送多播事件 消息者依赖关系图 预先为事件分配内存 可选的（无锁） Disruptor 核心概念 在我们理解Disruptor如何工作之前，了解下核心概念
Ring Buffer 环形数组设计，为了避免垃圾回收，采用的数组结构，从3.0开始，环形缓冲区主要存储和更新在Disruptor中移动的数据（事件） Sequence Disruptor 每个消费者(EventProcessor)维护一个 Sequence，并发的大多数代码都依赖 Sequence 值的改动，所以 Sequence 支持 AtomicLong 的大部分也行, 唯一不同的是 Sequence 包含额外的功能来阻止Sequence和其他值之间的伪共享(false sharing) Sequencer
Disruptor 核心逻辑, 两个实现: 单生产者和多生产者。他们实现了生产者与消费者之间的快速传递的并发算法。 Sequence Barrier 由 Sequencer 生成，包含此 Sequencer 发布的 Sequence 指针以及依赖的其他消费者的 Sequence。包含了消费者检查是否有可用的事件的代码。 Wait Strategy 消费者等待事件的策略，这个事件由生产者放入，决定了消费者怎么等待生产者将事件放入 Disruptor Event 生产者与消费者传递的事件，完全由用户定义 EventProcessor 处理事件的主要循环（main event loop），包含了一个 Sequeuece.</description></item></channel></rss>