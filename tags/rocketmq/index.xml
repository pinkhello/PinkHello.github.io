<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RocketMQ on pinkhello</title><link>https://pinkhello.cc/tags/rocketmq/</link><description>Recent content in RocketMQ on pinkhello</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>pinkhello</copyright><lastBuildDate>Sat, 31 Jul 2021 15:10:43 +0800</lastBuildDate><atom:link href="https://pinkhello.cc/tags/rocketmq/index.xml" rel="self" type="application/rss+xml"/><item><title>RocketMQ源码阅读 Consumer</title><link>https://pinkhello.cc/posts/28-rocketmq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-consumer/</link><pubDate>Sat, 31 Jul 2021 15:10:43 +0800</pubDate><guid>https://pinkhello.cc/posts/28-rocketmq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-consumer/</guid><description>RocketMQ Consumer 分为两类,
DefaultMQPullConsumer 标记为弃用 DefaultMQPushConsumer 我们这次只分析 DefaultMQPushConsumer
当前先看个 PushConsumer 代码
public class PushConsumer { public static void main(String[] args) throws InterruptedException, MQClientException { DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&amp;#34;CID_JODIE_1&amp;#34;); /** * 设置订阅的 可以对指定消息进行过滤，例如：&amp;#34;TopicTest&amp;#34;,&amp;#34;tagl||tag2||tag3&amp;#34;,*或null表示topic所有消息 */ consumer.subscribe(&amp;#34;TopicTest&amp;#34;, &amp;#34;*&amp;#34;); /** * CONSUME_FROM_LAST_OFFSET 第一次启动从队列最后位置消费，后续再启动接着上次消费的进度开始消费 * CONSUME_FROM_FIRST_OFFSET 第一次启动从队列初始位置消费，后续再启动接着上次消费的进度开始消费 * CONSUME_FROM_TIMESTAMP 第一次启动从指定时间点位置消费，后续再启动接着上次消费的进度开始消费 */ consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); //wrong time format 2017_0422_221800 consumer.setConsumeTimestamp(&amp;#34;20181109221800&amp;#34;); /** * 注册并发消费（消费监听） */ consumer.registerMessageListener(new MessageListenerConcurrently() { /** * ConsumeConcurrentlyStatus.CONSUME_SUCCESS 成功消费 * ConsumeConcurrentlyStatus.RECONSUME_LATER broker会根据设置的messageDelayLevel发起重试，默认16次 * @param msgs * @param context * @return */ @Override public ConsumeConcurrentlyStatus consumeMessage(List&amp;lt;MessageExt&amp;gt; msgs, ConsumeConcurrentlyContext context) { System.</description></item><item><title>RocketMQ源码阅读 Producer</title><link>https://pinkhello.cc/posts/27-rocketmq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-producer/</link><pubDate>Fri, 23 Jul 2021 15:10:37 +0800</pubDate><guid>https://pinkhello.cc/posts/27-rocketmq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-producer/</guid><description>在消息发送的时候, 我们先看 Producer 的启动代码
public class Producer { public static void main(String[] args) throws MQClientException, InterruptedException { DefaultMQProducer producer = new DefaultMQProducer(&amp;#34;ProducerGroupName&amp;#34;); producer.start(); for (int i = 0; i &amp;lt; 128; i++){ try { Message msg = new Message(&amp;#34;TopicTest&amp;#34;, &amp;#34;TagA&amp;#34;, &amp;#34;OrderID188&amp;#34;, &amp;#34;Hello world&amp;#34;.getBytes(RemotingHelper.DEFAULT_CHARSET)); SendResult sendResult = producer.send(msg); System.out.printf(&amp;#34;%s%n&amp;#34;, sendResult); } catch (Exception e) { e.printStackTrace(); } } producer.shutdown(); } } 非常简单的代码构建了一个 Producer 下面肯定有疑问:
Producer 如何启动的 Producer 发送消息流程 Producer 和 NameSever 如何交互 Producer 发送消息如何保证顺序 Producer 负载均衡如何实现的 Producer 延迟消息（发送的时候设置 Message 的延迟级别） Producer 端 如何启动的 第一步 可以看到启动一个 Producer 的代码, 核心类 DefaultMQProducer ,构造方法中又 New 了一个新的类 DefaultMQProducerImpl, 这个类是给真正的核心的类</description></item><item><title>RocketMQ源码阅读 NameServer</title><link>https://pinkhello.cc/posts/26-rocketmq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-nameserver/</link><pubDate>Tue, 25 May 2021 19:00:00 +0800</pubDate><guid>https://pinkhello.cc/posts/26-rocketmq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-nameserver/</guid><description>NameServer 角色 NameSever 在 RocketMQ 起到重要的角色，承担着路由管理、服务注册、服务发现等核心功能。
接收 Broker 的请求注册 Broker 路由信息 接收 Client 请求根据某个 topic 获取所有到 broker 的路由信息 NameSrv 核心类 NamesrvStartup public class NamesrvStartup { //... public static NamesrvController main0(String[] args) { try { NamesrvController controller = createNamesrvController(args); //启动 NamesrvController start(controller); String tip = &amp;#34;The Name Server boot success. serializeType=&amp;#34; + RemotingCommand.getSerializeTypeConfigInThisServer(); log.info(tip); System.out.printf(&amp;#34;%s%n&amp;#34;, tip); return controller; } catch (Throwable e) { e.printStackTrace(); System.exit(-1); } return null; } //... /** * 启动 NamesrvController * @param controller * @return * @throws Exception */ public static NamesrvController start(final NamesrvController controller) throws Exception { if (null == controller) { throw new IllegalArgumentException(&amp;#34;NamesrvController is null&amp;#34;); } // NamesrvController 初始化 boolean initResult = controller.</description></item><item><title>RocketMQ源码阅读 通信组件</title><link>https://pinkhello.cc/posts/25-rocketmq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E9%80%9A%E4%BF%A1%E7%BB%84%E4%BB%B6/</link><pubDate>Sat, 22 May 2021 16:09:45 +0800</pubDate><guid>https://pinkhello.cc/posts/25-rocketmq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E9%80%9A%E4%BF%A1%E7%BB%84%E4%BB%B6/</guid><description>RocketMQ 核心基石 前面已经介绍了 RocketMQ 的基本的概念和组件。今天我们开启真正的源码的阅读诗篇, RocketMQ 消息系各个组件 Producer、Consumer、Broker、NameSrv 通通离不开交互，那是使用的什么交互的呢。答案是TCP长链接。 而 RocketMQ 开源代码内部，对通信相关的进行了一次封装，都在 rocketmq-remoting 模块下，这个模块被其他 client、broker、namesrv 应用。
直接先说 remoting 的实现是基于 netty 做了封装、启动了服务端和客户端，支持三种消息的发送方式:
同步发送 单向发送 (不需要关注响应) 异步发送 下图为异步通信流程 remoting 包下的核心接口体系 接口 RemotingService public interface RemotingService { // 开启 void start(); // 关闭 void shutdown(); // 注册 RPCHook void registerRPCHook(RPCHook rpcHook); } 接口 RemotingServer public interface RemotingServer extends RemotingService { // 注册请求类型的处理器 【common 模块的 org.apache.rocketmq.common.protocol.RequestCode] void registerProcessor(final int requestCode, final NettyRequestProcessor processor, final ExecutorService executor); // 注册默认的处理器 void registerDefaultProcessor(final NettyRequestProcessor processor, final ExecutorService executor); // 本地的端口 int localListenPort(); // 根据 requestCode 获取处理器和业务线程池 Pair&amp;lt;NettyRequestProcessor, ExecutorService&amp;gt; getProcessorPair(final int requestCode); // 同步发送 RemotingCommand invokeSync(final Channel channel, final RemotingCommand request, final long timeoutMillis) throws InterruptedException, RemotingSendRequestException, RemotingTimeoutException; // 异步发送 void invokeAsync(final Channel channel, final RemotingCommand request, final long timeoutMillis, final InvokeCallback invokeCallback) throws InterruptedException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException; // 单向发送 void invokeOneway(final Channel channel, final RemotingCommand request, final long timeoutMillis) throws InterruptedException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException; } 实现 NettyRemotingServer 这边选择性的进行摘取记录描述啊</description></item><item><title>RocketMQ源码阅读 开篇</title><link>https://pinkhello.cc/posts/24-rocketmq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%80%E7%AF%87/</link><pubDate>Thu, 20 May 2021 10:02:20 +0800</pubDate><guid>https://pinkhello.cc/posts/24-rocketmq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%80%E7%AF%87/</guid><description>RocketMQ 是什么? RocketMQ 是 Alibaba 捐赠给 Apache 的一款分布式、队列模型的开源消息中间件。
Github https://github.com/apache/rocketmq 从官网也能看出它的一些特性:
低延迟 高可用 万亿级的消息支持 &amp;hellip; RocketMQ 基本概念 RocketMQ 是由 Producer、Broker、Consumer 三部分组成, Producer 负责生产 Message, Consumer 负责消费 Message, Broker 负责存储 Message。 每个 Broker 可以存储多个 Topic 的消息, 每个 Topic 的消息也可以分片存储在不同的 Broker 上。 Message Queue 用于存储消息的物理地址，每个 Topic 的消息地址存储于对歌 Message Queue 中。 Consumer Group 由多个 Consumer 实例组成。
Producer 负责生产消息，同步发送、异步发送、顺序发送、单向发送。同步和异步需要 Broker 确认信息，单向发送不需要。
Consumer 负责消费消息，一般异步消费。一个消费者会从 Broker 拉取消息。（拉取式消费、推动式消费）
Broker Server 负责存储、转发消息。 接收 Producer 发送来的消息并存储、同时为 Consumer 拉取请求做准备。当然也存储这消息相关的元数据（消费组、消费进度偏移、主题、队列消息等）
Name Server 为消息路由的提供者。Producer 和 Consumer 能够通过 它查找各个 Topic 相应的 Broker IP 列表，多个 Name Server 组成集群，相互独立、没有信息交换。</description></item></channel></rss>