<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on pinkhello</title><link>https://pinkhello.cc/tags/golang/</link><description>Recent content in golang on pinkhello</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>pinkhello</copyright><lastBuildDate>Sun, 27 Mar 2022 14:20:28 +0800</lastBuildDate><atom:link href="https://pinkhello.cc/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang for Range 探究</title><link>https://pinkhello.cc/posts/golang-for-range-%E6%8E%A2%E7%A9%B6/</link><pubDate>Sun, 27 Mar 2022 14:20:28 +0800</pubDate><guid>https://pinkhello.cc/posts/golang-for-range-%E6%8E%A2%E7%A9%B6/</guid><description>前言 今天在用 Golang 写 TCP 长链接的时候，在做测试的时候 for range 有在结构包的时候有性能问题。所以就细化探究了一下。
复现 假设有一个 Packet 类型([1024]byte)的数据包,我们从网络中获取到一个 [1024]Packet 的数据包，我们进行遍历
type Packet [1024]byte func BenchmarkForStruct_test(b *testing.B) { var items [1024]Packet var result Packet for i := 0; i &amp;lt; b.N; i++ { for k := 0; k &amp;lt; len(items); k++ { result = items[k] } } _ = result } func BenchmarkRangeStruct_test(b *testing.B) { var items [1024]Packet var result Packet for i := 0; i &amp;lt; b.</description></item><item><title>Golang的池化设计</title><link>https://pinkhello.cc/posts/43-golang%E7%9A%84%E6%B1%A0%E5%8C%96%E8%AE%BE%E8%AE%A1/</link><pubDate>Wed, 02 Feb 2022 02:52:28 +0800</pubDate><guid>https://pinkhello.cc/posts/43-golang%E7%9A%84%E6%B1%A0%E5%8C%96%E8%AE%BE%E8%AE%A1/</guid><description>Why Pool？ 先埋坑: Go 有没有池化的必要? 为什么要池化? Go 自从出生以来都被我们冠以&amp;quot;高并发&amp;quot;的Tag, 回头细想和深究一下，你会发现其实都是由 goroutine 实现的 , 我们都知道 与 Thread 相比， 创建 Goroutine 的代价非常小。从程序表现上，也像极了Thread, 每个 Program 至少包含一个 Goroutine(至少一个**Main Goroutine**) 所有的其他 Goroutines 都依附于 Main Goroutine（如果 Main Goroutine Terminated, 其他 Goroutines 也会 Terminated）, Goroutine 总是工作在后台。
多线程``多进程是为了提高系统的并发能力，当前系统下，这边就需要系统调度，一个线程可以拆分为 &amp;quot;用户态&amp;quot;线程 和 &amp;quot;内核态&amp;quot;线程，这两者需要进行绑定，我们一般称 内核态线程 为线程，用户态线程为协程
从上面可以看出 协程 和 线程 有映射关系，这样就来了 M:N 关系(为什么不是 1:1, N:1 ? )
Goroutine 优点:
相比 Thread 代价更小 Goroutine 其在 stack 的大小可以根据程序要求进行变化，但是 Thread 是固定的 Goroutine 使用 Channel 进行通信，Channel 用于 Goroutines 访问共享内存的时候防止竞争的。 从程序上一个线程可能拥有许多的 Goroutines 关联，如果这些关联的 有一个 Goroutine 去阻塞了线程，那么剩余的 Goroutine 将分配给其他的 OS Thread，且这种切换操作是对开发者屏蔽的。 Goroutine 调度器 回头看将 Goroutine 和 协程 有区别的。调度</description></item><item><title>探秘负载均衡</title><link>https://pinkhello.cc/posts/36-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%80%9D%E8%80%83/</link><pubDate>Fri, 01 Oct 2021 10:04:00 +0800</pubDate><guid>https://pinkhello.cc/posts/36-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%80%9D%E8%80%83/</guid><description>前言 今天是国庆的第3天，在此恭祝小哥哥和小姐姐们⛱️节日快乐！ 微信朋友圈🀄️全部是 旅途ING。
我的国庆：
第一天: 带🪆 第二天: 被启东坑了一回 第三天: 🈚️孩一身轻 &amp;hellip;&amp;hellip; 对于我这种社交尴尬者，⛱️度假最好的方式还是学习。
今日带来了 自己对于负载均衡(load balance)的学习。
度假最好的方式是学习 GRPC在负载均衡的设计: Load-balancing.md
为什么要负载均衡 在如今的互联网领域，对于数据的大爆发，高频的请求，对于提供服务的企业来说是不小的IT资源开销。为了解决资源中的负载分配，并且使得资源的利用率达到最大。出现了负载均衡，主要为了解决 高并发 和 高可用。
负载均衡的实现方式有：软件 和 硬件。这次我学习的主是软件方式。
负载均衡的算法 轮询( Round Robin ) &amp;amp; 加权轮询( Weight Round Robin ) : 随机 &amp;amp; 加权随机 最少连接( Last Connections ) : 通过将流量引导到第一个可用服务器然后将该服务器移动到队列底部来轮换服务器，当服务器具有相同的规格并且没有很多持久连接时最有用。 哈希( Hash ) eg: ip hash 一致性哈希( Consistent Hash ) eg: request_url 一致性哈希 最少响应时间 : 将流量定向到活动连接最少且平均响应时间最短的服务器。 常用的负载均衡手段 Load-balancing.md 已经介绍了以下几种</description></item></channel></rss>