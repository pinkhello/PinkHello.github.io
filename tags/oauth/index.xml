<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Oauth on pinkhello</title><link>https://pinkhello.cc/tags/oauth/</link><description>Recent content in Oauth on pinkhello</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>pinkhello</copyright><lastBuildDate>Wed, 10 Feb 2021 08:00:00 +0800</lastBuildDate><atom:link href="https://pinkhello.cc/tags/oauth/index.xml" rel="self" type="application/rss+xml"/><item><title>OAuth2.0 那点事</title><link>https://pinkhello.cc/posts/05-oauth2.0%E9%82%A3%E7%82%B9%E4%BA%8B/</link><pubDate>Wed, 10 Feb 2021 08:00:00 +0800</pubDate><guid>https://pinkhello.cc/posts/05-oauth2.0%E9%82%A3%E7%82%B9%E4%BA%8B/</guid><description>OAuth2.0 是什么? OAuth2.0 Framework RFC 6749 [https://tools.ietf.org/html/rfc6749]
OAuth 就是一种授权机制，它介于客户端与资源所有者的授权层，为了分离不同的角色。 在资源所有者同意并向客户端颁发令牌后，客户端携带令牌可以访问部分或全部资源。
OAuth2.0是OAuth协议的一个版本，为2.0版本。有意思的是 2.0与 1.0并不兼容。
OAuth2.0 授权方式 获取授权的过程
授权码(authorization-code) 隐藏式(implicit) 密码(password) 客户端凭证(client credentials) 不管哪种方式，都需要在第三方应用申请令牌之前，需要在系统中申请身份唯一标识: 客户端ID Client ID和 客户端秘钥 Client Secret. 这样能确保Token不被恶意使用。
授权重要的参数和指标:
response_type响应类型: code(要求返回授权码),token(要求返回授权Token) client_id客户端身份标识 client_secret客户端秘钥 redirect_uri重定向地址 scope授权范围, read只读权限, all全部权限 grant_type授权方式 authorization_code(授权码)、password(密码)、client_credentials(凭证)、refresh_token(更新令牌) state应用程序传递的一个随机数，防止 CSRF攻击 授权码 在访问第三方应用先申请一个授权码，然后再用授权码获取令牌.这种方式也是最常用的流程，安全性也是最高的，适用于有后端的Web应用。授权码通过前端传送，令牌存储在后端。所有的和资源服务器的交互都在服务端完成，避免了令牌的泄露。 授权码和令牌的在 浏览器和客户端WEB应用以及资源服务器的交互流程大致如下: 1.2.3.4 用户选择 Google登陆 yelp.com 3.4 Yelp.com请求用户授权 Google权限 5.6 用户同意后返回授权码 7.8 Yelp.com通过授权码 会向 Google发起请求Token 9 验证必要参数，返回 Token 10.11 操作请求 隐藏式 密码式 顾名思议,在自己的系统输入第三方系统的账号密码,自己的系统拿账号密码去申请令牌，响应题里面返回token</description></item></channel></rss>