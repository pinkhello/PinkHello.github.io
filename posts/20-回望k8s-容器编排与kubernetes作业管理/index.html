<!doctype html><html lang=en-us><head><link rel=preload href=/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><script type=text/javascript src=https://latest.cactus.chat/cactus.js></script>
<link rel=stylesheet href=https://latest.cactus.chat/style.css type=text/css><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>回望K8S 容器编排与Kubernetes作业管理 | pinkhello</title><link rel=canonical href=https://pinkhello.cc/posts/20-%E5%9B%9E%E6%9C%9Bk8s-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8Ekubernetes%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86/><meta name=description content="👷Hey! 我是 **pinkhello**，💻 一名后端程序员。**重要提示**: 在您阅读文章并评论之前，请先认真阅读[**评论承诺**](http://pinkhello.cc/promise)。"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="回望K8S 容器编排与Kubernetes作业管理"><meta property="og:description" content="Pod pod 是 Kubernetes 项目的最小的 API 对象，原子调度单位.
假设 &ldquo;容器的本质是进程&rdquo;，容器镜像就是 exe 安装包, kubernetes 是操作系统
Pod 最重要的一个事实是一个逻辑概念。它对于 Kubernetes 最核心的意义是 容器设计模式。Kubernetes 真正处理的还是宿主机上操作系统上的 Linux 容器的 Namespace 和 Cgroups，而不是一个所谓的 Pod 边界和隔离环境。
Pod 其实是一组共享了某些资源的容器。Pod 里面所有的容器，共享的同一个 Network Namespace，并且可以声明共享同一个 Volume.
Kubernetes 项目内部，Pod 实现需要使用一个中间容器，这个容器叫做 Infra 容器，在 Pod 中，Infra 容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过 Join Network Namespace 的方式，与 Infra 容器关联在一起。
sidecar 典型的例子：WAR 包和 Web 服务器 POD后，将 WAR 包和 Tomcat 分别做成镜像，可以把他们容器结合在一起
--- apiVersion: v1 kind: Pod metadata: name: javaweb-2 spec: # 启动后做了一件事 把应用的WAR包拷贝到 /app目录中，后退出 initContainers: - image: sample-war:v2 name: war command: [&#34;cp&#34;, &#34;/sample."><meta property="og:type" content="article"><meta property="og:url" content="https://pinkhello.cc/posts/20-%E5%9B%9E%E6%9C%9Bk8s-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8Ekubernetes%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-17T08:00:00+08:00"><meta property="article:modified_time" content="2021-05-17T08:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="回望K8S 容器编排与Kubernetes作业管理"><meta name=twitter:description content="Pod pod 是 Kubernetes 项目的最小的 API 对象，原子调度单位.
假设 &ldquo;容器的本质是进程&rdquo;，容器镜像就是 exe 安装包, kubernetes 是操作系统
Pod 最重要的一个事实是一个逻辑概念。它对于 Kubernetes 最核心的意义是 容器设计模式。Kubernetes 真正处理的还是宿主机上操作系统上的 Linux 容器的 Namespace 和 Cgroups，而不是一个所谓的 Pod 边界和隔离环境。
Pod 其实是一组共享了某些资源的容器。Pod 里面所有的容器，共享的同一个 Network Namespace，并且可以声明共享同一个 Volume.
Kubernetes 项目内部，Pod 实现需要使用一个中间容器，这个容器叫做 Infra 容器，在 Pod 中，Infra 容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过 Join Network Namespace 的方式，与 Infra 容器关联在一起。
sidecar 典型的例子：WAR 包和 Web 服务器 POD后，将 WAR 包和 Tomcat 分别做成镜像，可以把他们容器结合在一起
--- apiVersion: v1 kind: Pod metadata: name: javaweb-2 spec: # 启动后做了一件事 把应用的WAR包拷贝到 /app目录中，后退出 initContainers: - image: sample-war:v2 name: war command: [&#34;cp&#34;, &#34;/sample."><link rel=stylesheet href=https://pinkhello.cc/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="><link rel=stylesheet href=https://pinkhello.cc/css/pinkhello.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://pinkhello.cc/images/favicon.ico><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','G-M2FXWC325L','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class="max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a>
<a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a>
<a id=top-icon-tablet href=# onclick="$('html, body').animate({scrollTop:0},'fast')" style=display:none aria-label="Top of Page"><i class="fas fa-chevron-up fa-lg"></i></a>
<span id=menu><span id=nav><ul><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/categories>Category</a></li><li><a href=/tags>Tag</a></li><li><a href=/index.xml>Rss</a></li><li><a href=/jobs>Job</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=https://pinkhello.cc/posts/19-%E5%9B%9E%E6%9C%9Bk8s-kubernetes%E6%8B%BC%E5%9B%BE/ aria-label=Previous><i class="fas fa-chevron-left" aria-hidden=true onmouseover="$('#i-prev').toggle()" onmouseout="$('#i-prev').toggle()"></i></a></li><li><a class=icon href=https://pinkhello.cc/posts/22-%E5%9B%9E%E6%9C%9Bk8s-%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/ aria-label=Next><i class="fas fa-chevron-right" aria-hidden=true onmouseover="$('#i-next').toggle()" onmouseout="$('#i-next').toggle()"></i></a></li><li><a class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast')" aria-label="Top of Page"><i class="fas fa-chevron-up" aria-hidden=true onmouseover="$('#i-top').toggle()" onmouseout="$('#i-top').toggle()"></i></a></li><li><a class=icon href=# aria-label=Share><i class="fas fa-share-alt" aria-hidden=true onmouseover="$('#i-share').toggle()" onmouseout="$('#i-share').toggle()" onclick="return $('#share').toggle(),!1"></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f" aria-label=Facebook><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f&text=%e5%9b%9e%e6%9c%9bK8S%20%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8eKubernetes%e4%bd%9c%e4%b8%9a%e7%ae%a1%e7%90%86" aria-label=Twitter><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f&title=%e5%9b%9e%e6%9c%9bK8S%20%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8eKubernetes%e4%bd%9c%e4%b8%9a%e7%ae%a1%e7%90%86" aria-label=Linkedin><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f&is_video=false&description=%e5%9b%9e%e6%9c%9bK8S%20%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8eKubernetes%e4%bd%9c%e4%b8%9a%e7%ae%a1%e7%90%86" aria-label=Pinterest><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=%e5%9b%9e%e6%9c%9bK8S%20%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8eKubernetes%e4%bd%9c%e4%b8%9a%e7%ae%a1%e7%90%86&body=Check out this article: https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f" aria-label=Email><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f&title=%e5%9b%9e%e6%9c%9bK8S%20%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8eKubernetes%e4%bd%9c%e4%b8%9a%e7%ae%a1%e7%90%86" aria-label=Pocket><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f&title=%e5%9b%9e%e6%9c%9bK8S%20%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8eKubernetes%e4%bd%9c%e4%b8%9a%e7%ae%a1%e7%90%86" aria-label=reddit><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f&name=%e5%9b%9e%e6%9c%9bK8S%20%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8eKubernetes%e4%bd%9c%e4%b8%9a%e7%ae%a1%e7%90%86&description=Pod%20pod%20%e6%98%af%20Kubernetes%20%e9%a1%b9%e7%9b%ae%e7%9a%84%e6%9c%80%e5%b0%8f%e7%9a%84%20API%20%e5%af%b9%e8%b1%a1%ef%bc%8c%e5%8e%9f%e5%ad%90%e8%b0%83%e5%ba%a6%e5%8d%95%e4%bd%8d.%0a%e5%81%87%e8%ae%be%20%26ldquo%3b%e5%ae%b9%e5%99%a8%e7%9a%84%e6%9c%ac%e8%b4%a8%e6%98%af%e8%bf%9b%e7%a8%8b%26rdquo%3b%ef%bc%8c%e5%ae%b9%e5%99%a8%e9%95%9c%e5%83%8f%e5%b0%b1%e6%98%af%20exe%20%e5%ae%89%e8%a3%85%e5%8c%85%2c%20kubernetes%20%e6%98%af%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%0aPod%20%e6%9c%80%e9%87%8d%e8%a6%81%e7%9a%84%e4%b8%80%e4%b8%aa%e4%ba%8b%e5%ae%9e%e6%98%af%e4%b8%80%e4%b8%aa%e9%80%bb%e8%be%91%e6%a6%82%e5%bf%b5%e3%80%82%e5%ae%83%e5%af%b9%e4%ba%8e%20Kubernetes%20%e6%9c%80%e6%a0%b8%e5%bf%83%e7%9a%84%e6%84%8f%e4%b9%89%e6%98%af%20%e5%ae%b9%e5%99%a8%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e3%80%82Kubernetes%20%e7%9c%9f%e6%ad%a3%e5%a4%84%e7%90%86%e7%9a%84%e8%bf%98%e6%98%af%e5%ae%bf%e4%b8%bb%e6%9c%ba%e4%b8%8a%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e4%b8%8a%e7%9a%84%20Linux%20%e5%ae%b9%e5%99%a8%e7%9a%84%20Namespace%20%e5%92%8c%20Cgroups%ef%bc%8c%e8%80%8c%e4%b8%8d%e6%98%af%e4%b8%80%e4%b8%aa%e6%89%80%e8%b0%93%e7%9a%84%20Pod%20%e8%be%b9%e7%95%8c%e5%92%8c%e9%9a%94%e7%a6%bb%e7%8e%af%e5%a2%83%e3%80%82%0aPod%20%e5%85%b6%e5%ae%9e%e6%98%af%e4%b8%80%e7%bb%84%e5%85%b1%e4%ba%ab%e4%ba%86%e6%9f%90%e4%ba%9b%e8%b5%84%e6%ba%90%e7%9a%84%e5%ae%b9%e5%99%a8%e3%80%82Pod%20%e9%87%8c%e9%9d%a2%e6%89%80%e6%9c%89%e7%9a%84%e5%ae%b9%e5%99%a8%ef%bc%8c%e5%85%b1%e4%ba%ab%e7%9a%84%e5%90%8c%e4%b8%80%e4%b8%aa%20Network%20Namespace%ef%bc%8c%e5%b9%b6%e4%b8%94%e5%8f%af%e4%bb%a5%e5%a3%b0%e6%98%8e%e5%85%b1%e4%ba%ab%e5%90%8c%e4%b8%80%e4%b8%aa%20Volume.%0aKubernetes%20%e9%a1%b9%e7%9b%ae%e5%86%85%e9%83%a8%ef%bc%8cPod%20%e5%ae%9e%e7%8e%b0%e9%9c%80%e8%a6%81%e4%bd%bf%e7%94%a8%e4%b8%80%e4%b8%aa%e4%b8%ad%e9%97%b4%e5%ae%b9%e5%99%a8%ef%bc%8c%e8%bf%99%e4%b8%aa%e5%ae%b9%e5%99%a8%e5%8f%ab%e5%81%9a%20Infra%20%e5%ae%b9%e5%99%a8%ef%bc%8c%e5%9c%a8%20Pod%20%e4%b8%ad%ef%bc%8cInfra%20%e5%ae%b9%e5%99%a8%e6%b0%b8%e8%bf%9c%e9%83%bd%e6%98%af%e7%ac%ac%e4%b8%80%e4%b8%aa%e8%a2%ab%e5%88%9b%e5%bb%ba%e7%9a%84%e5%ae%b9%e5%99%a8%ef%bc%8c%e8%80%8c%e5%85%b6%e4%bb%96%e7%94%a8%e6%88%b7%e5%ae%9a%e4%b9%89%e7%9a%84%e5%ae%b9%e5%99%a8%ef%bc%8c%e5%88%99%e9%80%9a%e8%bf%87%20Join%20Network%20Namespace%20%e7%9a%84%e6%96%b9%e5%bc%8f%ef%bc%8c%e4%b8%8e%20Infra%20%e5%ae%b9%e5%99%a8%e5%85%b3%e8%81%94%e5%9c%a8%e4%b8%80%e8%b5%b7%e3%80%82%0asidecar%20%e5%85%b8%e5%9e%8b%e7%9a%84%e4%be%8b%e5%ad%90%ef%bc%9aWAR%20%e5%8c%85%e5%92%8c%20Web%20%e6%9c%8d%e5%8a%a1%e5%99%a8%20POD%e5%90%8e%ef%bc%8c%e5%b0%86%20WAR%20%e5%8c%85%e5%92%8c%20Tomcat%20%e5%88%86%e5%88%ab%e5%81%9a%e6%88%90%e9%95%9c%e5%83%8f%ef%bc%8c%e5%8f%af%e4%bb%a5%e6%8a%8a%e4%bb%96%e4%bb%ac%e5%ae%b9%e5%99%a8%e7%bb%93%e5%90%88%e5%9c%a8%e4%b8%80%e8%b5%b7%0a---%20apiVersion%3a%20v1%20kind%3a%20Pod%20metadata%3a%20name%3a%20javaweb-2%20spec%3a%20%23%20%e5%90%af%e5%8a%a8%e5%90%8e%e5%81%9a%e4%ba%86%e4%b8%80%e4%bb%b6%e4%ba%8b%20%e6%8a%8a%e5%ba%94%e7%94%a8%e7%9a%84WAR%e5%8c%85%e6%8b%b7%e8%b4%9d%e5%88%b0%20%2fapp%e7%9b%ae%e5%bd%95%e4%b8%ad%ef%bc%8c%e5%90%8e%e9%80%80%e5%87%ba%20initContainers%3a%20-%20image%3a%20sample-war%3av2%20name%3a%20war%20command%3a%20%5b%26%2334%3bcp%26%2334%3b%2c%20%26%2334%3b%2fsample." aria-label=Tumblr><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f&t=%e5%9b%9e%e6%9c%9bK8S%20%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8eKubernetes%e4%bd%9c%e4%b8%9a%e7%ae%a1%e7%90%86" aria-label="Hacker News"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">回望K8S 容器编排与Kubernetes作业管理</h1><div class=meta><div class=postdate><time datetime="2021-05-17 08:00:00 +0800 +0800" itemprop=datePublished>2021-05-17</time></div><div class=article-category><i class="fas fa-archive"></i>
<a class=category-link href=/categories/tech>Tech</a></div><div class=article-tag><i class="fas fa-tag"></i>
<a class=tag-link href=/tags/k8s rel=tag>k8s</a></div></div></header><div id=toc><nav id=TableOfContents><ul><li><a href=#sidecar><code>sidecar</code></a><ul><li><a href=#典型的例子war-包和-web-服务器>典型的例子：WAR 包和 Web 服务器</a></li><li><a href=#容器的日志收集>容器的日志收集</a></li></ul></li></ul><ul><li><a href=#pod-的水平扩展--收缩horizontal-scaling-outin>Pod 的“水平扩展 / 收缩”（horizontal scaling out/in）</a></li><li><a href=#滚动更新>滚动更新</a></li></ul><ul><li><a href=#拓扑状态>拓扑状态</a></li><li><a href=#存储状态>存储状态</a></li><li><a href=#statefulset-的工作原理>StatefulSet 的工作原理</a></li></ul><ul><li><a href=#常用的使用-job对象的方法>常用的使用 Job对象的方法</a></li><li><a href=#cronjob-对象>CronJob 对象</a></li></ul></nav></div><div class=content itemprop=articleBody><h1 id=pod>Pod</h1><p><code>pod</code> 是 <code>Kubernetes</code> 项目的最小的 API 对象，原子调度单位.</p><p>假设 &ldquo;容器的本质是进程&rdquo;，容器镜像就是 exe 安装包, kubernetes 是操作系统</p><p><code>Pod</code> 最重要的一个事实是一个逻辑概念。它对于 <code>Kubernetes</code> 最核心的意义是 <code>容器设计模式</code>。<code>Kubernetes</code> 真正处理的还是宿主机上操作系统上的 <code>Linux</code> 容器的 <code>Namespace</code> 和 <code>Cgroups</code>，而不是一个所谓的 <code>Pod</code> 边界和隔离环境。</p><p><code>Pod</code> 其实是一组共享了某些资源的容器。<code>Pod</code> 里面所有的容器，共享的同一个 <code>Network Namespace</code>，并且可以声明共享同一个 <code>Volume</code>.</p><p><code>Kubernetes</code> 项目内部，<code>Pod</code> 实现需要使用一个中间容器，这个容器叫做 <code>Infra</code> 容器，在 <code>Pod</code> 中，<code>Infra</code> 容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过 <code>Join Network Namespace</code> 的方式，与 <code>Infra</code> 容器关联在一起。</p><h2 id=sidecar><code>sidecar</code></h2><h3 id=典型的例子war-包和-web-服务器>典型的例子：WAR 包和 Web 服务器</h3><p><code>POD</code>后，将 <code>WAR</code> 包和 <code>Tomcat</code> 分别做成镜像，可以把他们容器结合在一起</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>javaweb-2</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span><span style=color:#75715e>#  启动后做了一件事 把应用的WAR包拷贝到 /app目录中，后退出</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>initContainers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>sample-war:v2</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>war</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>command</span>: [<span style=color:#e6db74>&#34;cp&#34;</span>, <span style=color:#e6db74>&#34;/sample.war&#34;</span>, <span style=color:#e6db74>&#34;/app&#34;</span>]
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/app</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>app-volume</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>tomcat:7.0</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>tomcat</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>command</span>: [<span style=color:#e6db74>&#34;sh&#34;</span>,<span style=color:#e6db74>&#34;-c&#34;</span>,<span style=color:#e6db74>&#34;/root/apache-tomcat-7.0.42-v2/bin/start.sh&#34;</span>]
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/root/apache-tomcat-7.0.42-v2/webapps</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>app-volume</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>hostPort</span>: <span style=color:#ae81ff>8001</span> 
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>app-volume</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>emptyDir</span>: {}
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>这个<code>POD</code>中，定义了两个容器，第一个容器镜像<code> sample-war:v2</code>，第二个容器镜像是 <code>Tomcat</code> 镜像，War包容器的类型不是一个普通容器，是一个 <code>Init Container</code> 类型的容器。</p><p>在Pod中，所有 <code>Init Container</code> 定义的容器，都比 <code>spec.containers</code> 定义的用户容器先启动。并且， <code>Init Container</code> 容器会按顺序准一启动，而直到他们都启动并且退出了，用户容器才会启动。</p><p>这种组合的方式，正是容器设计模式里面最常用的一种模式：<code>sidecar</code></p><h3 id=容器的日志收集>容器的日志收集</h3><p>应用把日志文件输出到容器的 <code>/var/log</code> 目录中，<code>Pod</code>的 <code>Volume</code> 挂载到应用容器的 <code>/var/log</code> 目录上，然后在这个 <code>Pod</code> 里的运行一个 <code>sidecar</code> 容器，也声明挂载同一个 <code>Volume</code> 到自己的 <code>/var/log</code> 目录上，
这样这个 <code>sidecar</code> 容器只需要做一件事，把自己的 <code>/var/log</code> 目录中读取日志文件，转发就可以了，就是一个基本的日志收集</p><h1 id=pod-对象的基本概念><code>Pod</code> 对象的基本概念</h1><p><code>Pod</code> 是容器环境的 <code>Kubernetes</code> 的基本单元，调度、网络、存储、以及安全相关的熟悉，都是属于 <code>Pod</code> 级别的。</p><p><code>Pod</code> 下重要的字段和含义</p><ul><li><code>NodeSelector</code> : 用户将 <code>Pod</code> 和 <code>Node</code> 绑定的字段</li><li><code>NodeName</code> : 一旦 <code>Pod</code> 的这个阻断被赋值，<code>K8S</code> 会认为这个 <code>Pod</code> 已经经过调度。</li><li><code>HostAliases</code>：定义了 <code>Pod</code> 的 <code>hosts</code> 文件（比如 <code>/etc/hosts</code>）里的内容</li></ul><p>凡是跟容器的 <code>Linux Namespace</code> 相关的属性，也一定是 <code>Pod</code> 级别的。
<code>shareProcessNamespace=true</code></p><p><code>Pod</code> 对象在 <code>Kubernetes</code> 中的生命周期。<code>Pod</code> 生命周期的变化，主要体现在 <code>Pod API 对象</code>的 <code>Status</code> 部分，这是它除了 <code>Metadata</code> 和 <code>Spec</code> 之外的第三个重要字段。其中，<code>pod.status.phase</code>，就是 <code>Pod</code> 的当前状态，
它有如下几种可能的情况：</p><ul><li><code>Pending</code>。这个状态意味着，<code>Pod</code> 的 <code>YAML</code> 文件已经提交给了 <code>Kubernetes</code>，<code>API</code> 对象已经被创建并保存在 <code>Etcd</code> 当中。但是，这个 <code>Pod</code> 里有些容器因为某种原因而不能被顺利创建。比如，调度不成功。</li><li><code>Running</code>。这个状态下，<code>Pod</code> 已经调度成功，跟一个具体的节点绑定。它包含的容器都已经创建成功，并且至少有一个正在运行中。</li><li><code>Succeeded</code>。这个状态意味着，<code>Pod</code> 里的所有容器都正常运行完毕，并且已经退出了。这种情况在运行一次性任务时最为常见。</li><li><code>Failed</code>。这个状态下，<code>Pod</code> 里至少有一个容器以不正常的状态（非 0 的返回码）退出。这个状态的出现，意味着你得想办法 <code>Debug</code> 这个容器的应用，比如查看 <code>Pod</code> 的 <code>Events</code> 和日志。</li><li><code>Unknown</code>。这是一个异常状态，意味着 <code>Pod</code> 的状态不能持续地被 <code>kubelet</code> 汇报给 <code>kube-apiserver</code>，这很有可能是主从节点（<code>Master</code> 和 <code>Kubelet</code>）间的通信出现了问题。</li></ul><h1 id=kubernetes-其他对象-volume><code>Kubernetes</code> 其他对象 <code>Volume</code></h1><p><code>Kubernetes</code> 支持的 <code>Project Volume</code> 一共有四种:</p><ul><li><code>Secret</code> : 把 Pod 想要访问的加密数据，存放到 <code>Etcd</code> 中，然后通过在 Pod 的容器里挂载 Volume 的方式。</li><li><code>ConfigMap</code> : 保存的是不需要加密的、应用所需的配置信息。而 <code>ConfigMap</code> 的用法几乎与 <code>Secret</code> 完全相同：你可以使用 <code>kubectl create configmap</code> 从文件或者目录创建 <code>ConfigMap</code>，也可以直接编写 <code>ConfigMap</code> 对象的 <code>YAML</code> 文件。</li><li><code>Downward API</code> : 让 Pod 里的容器能够直接获取到这个<code> Pod API</code> 对象本身的信息。<blockquote><p>一定是 Pod 里的容器进程启动之前就能够确定下来的信息。而如果你想要获取 Pod 容器运行后才会出现的信息，比如，容器进程的 <code>PID</code>，那就肯定不能使用 <code>Downward API</code> 了，而应该考虑在 <code>Pod</code> 里定义一个 <code>sidecar</code> 容器。</p></blockquote></li><li><code>ServiceAccountToken</code> : 这种把 <code>Kubernetes</code> 客户端以容器的方式运行在集群里，然后使用 <code>default Service Account</code> 自动授权的方式，被称作“InClusterConfig”.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Secret</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>mysecret</span>
</span></span><span style=display:flex><span><span style=color:#f92672>type</span>: <span style=color:#ae81ff>Opaque</span>
</span></span><span style=display:flex><span><span style=color:#f92672>data</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>user</span>: <span style=color:#ae81ff>YWRtaW4=</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>pass</span>: <span style=color:#ae81ff>MWYyZDFlMmU2N2Rm</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; kubectl create secret
</span></span></code></pre></div><h1 id=容器的健康检查和恢复机制>容器的健康检查和恢复机制</h1><p><code>Pod</code> 容器定义了一个健康检查的"探针"（Probe）, 这样kubelet就会根据这个 probe 返回的值决定这个容器的状态，而不是直接以容器镜像十分运行来作为依据。生产环境保证应用健康存活的重要手段。</p><p><code>Pod</code> 恢复机制 restartPolicy, 它是 Pod 的 Spec 部分的一个标准字段（<code>pod.spec.restartPolicy</code>），默认值是 <code>Always</code>，即：任何时候这个容器发生了异常，它一定会被重新创建。</p><blockquote><p><code>pod</code> 恢复，永远只发生在当前节点，而不会跑到别的节点上去。（不会发生故障转移）需要转移的需要切换到 <code>Deployment</code> 这样的控制器来管理<code>POD</code></p></blockquote><p>你还可以通过设置 <code>restartPolicy</code>，改变 <code>Pod</code> 的恢复策略。除了 <code>Always</code>，它还有 <code>OnFailure</code> 和 <code>Never</code> 两种情况：</p><ul><li><code>Always</code>：在任何情况下，只要容器不在运行状态，就自动重启容器；</li><li><code>OnFailure</code>: 只在容器 异常时才自动重启容器；</li><li><code>Never</code>: 从来不重启容器。</li></ul><h1 id=编排其实很简单-控制器模型>编排其实很简单-&ldquo;控制器"模型</h1><p>前面已经知道 <code>POD</code> 是一个复杂的<code>API对象</code>，实际也是对容器的进一步抽象和封装；也就是说<code>Pod对象</code>是容器的升级版,它对容器的组合，添加了很多的属性和字段。</p><p><code>Kubernetes</code>操作<code>POD</code>是依赖控制器(Controller)完成的。就是 kube-controller-manager 组件</p><p>通过查看 <code>https://github.com/kubernetes/kubernetes/tree/master/pkg/controller</code> 源代码下能看见这些目录</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment/ job/ podautoscaler/ cloud/ disruption/ namespace/ 
</span></span><span style=display:flex><span>replicaset/ serviceaccount/ volume/cronjob/ garbagecollector/ nodelifecycle/ 
</span></span><span style=display:flex><span>replication/ statefulset/ daemon/...
</span></span></code></pre></div><p>这些每个目录都是一种类型的 <code>controller</code>,各自负责某种编排功能。</p><p>控制循环（control loop）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>实际状态</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>获取集群中对象X的实际状态</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#a6e22e>Actual</span> <span style=color:#a6e22e>State</span><span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>期望状态</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>获取集群中对象X的期望状态</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#a6e22e>Desired</span> <span style=color:#a6e22e>State</span><span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>实际状态</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>期望状态</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>什么都不做</span>
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>执行编排动作</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>将实际状态调整为期望状态</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>具体实现时候，<code>实际状态</code>来自于<code>Kubernetes</code> 集群本身，<code>期望状态</code>来自于用户提交的 <code>YAML</code> 文件。</p><blockquote><p>比如</p><ul><li><code>Deployment控制器</code>从<code>Etcd</code>中获取到目标标签的 <code>POD</code>，然后统计他们的数量，这是实际状态；</li><li><code>Deployment对象</code>的 <code>Replicas</code> 字段的值是期望状态；</li><li><code>Deployment控制器</code>将两个状态做比较，然后根据比较结果，确定创建<code>POD</code>还是删除已经存在的<code>POD</code></li></ul></blockquote><p>这个操作叫做协调（<code>Reconcile</code>）即 控制循环</p><blockquote><p>为什么是循环，因为事件往往是一次性的，如果操作失败比较难处理，但是控制器循环一直尝试，更符合 Kubernetes 声明式API，最终达成一致。</p></blockquote><p><img src=/%E5%9B%9E%E6%9C%9BK8S/deployment.png alt=deployment结构></p><p>上半部分的控制器定义（包含期望状态），下面的部分被控制对象的模板组成的。</p><h1 id=作业副本和水平扩展>作业副本和水平扩展</h1><h2 id=pod-的水平扩展--收缩horizontal-scaling-outin>Pod 的“水平扩展 / 收缩”（horizontal scaling out/in）</h2><p>如果我们更新了 <code>Deployment</code> 的 <code>Pod</code> 模板（假如更新了容器镜像），那么 <code>Deployment</code> 需要遵循一种 &ldquo;滚动更新&rdquo;（<code>rolling update</code>）的方式来升级现有的容器。这也是 <code>kubernetes</code> 重要的概念（API对象）：<code>ReplicaSet</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ReplicaSet</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-set</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.7.9</span>
</span></span></code></pre></div><p>一个 <code>ReplicaSet</code>对象，由 副本数目的定义和一个Pod模板组成的。它其实是 <code>Deployment</code> 的子集。而且，<code>Deployment控制器</code>操作的正是 <code>ReplicaSet</code> 对象，而不是<code>Pod对象</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale
</span></span></code></pre></div><p><img src=/%E5%9B%9E%E6%9C%9BK8S/replicaset.jpg alt=ReplicaSet结构></p><h2 id=滚动更新>滚动更新</h2><p>将一个集群中正在运行的多个 <code>Pod</code> 版本，交替地逐一升级的过程，就是“滚动更新”。</p><blockquote><ul><li>依赖 <code>health check</code> 机制</li><li>保证服务的连续性</li></ul></blockquote><p><img src=/%E5%9B%9E%E6%9C%9BK8S/deployment-replicaset-pod.jpg alt=DeploymentReplicaSet></p><p><code>Deployment</code> 实际上是一个两层控制器。首先，它通过 <code>ReplicaSet</code> 的个数来描述应用的版本；然后，它再通过 <code>ReplicaSet</code> 的属性（比如 <code>replicas</code> 的值），来保证 <code>Pod</code> 的副本数量。</p><h1 id=深入理解statefulset>深入理解StatefulSet</h1><ul><li>拓扑状态：应用间不完全对等，需要谁先启动，谁后启动，必须按照某些顺序来启动。（在<code>Pod</code>删除和再创建中保持稳定）</li><li>存储状态：多个实例绑定了不同的存储数据，一个数据库应用的多个存储实例</li></ul><h2 id=拓扑状态>拓扑状态</h2><p>StatefulSet 核心功能：通过某种方式纪录这些状态，等POD被重新创建时候，能够为新的POD恢复状态。</p><p>Headless Service</p><p>Service 是 Kubernetes 项目中用来将一组 Pod 暴露给外界访问的一种机制。比如，一个 <code>Deployment</code> 有 <code>3</code> 个 <code>Pod</code>，那么我就可以定义一个 <code>Service</code>。然后，用户只要能访问到这个 <code>Service</code>，它就能访问到某个具体的 <code>Pod</code>。</p><ul><li>第一种方式，是以 <code>Service</code> 的 <code>VIP</code>（<code>Virtual IP</code>，即：虚拟 IP）方式。</li><li>第二种方式，就是以 <code>Service</code> 的 <code>DNS</code> 方式, 比如 只要我访问“<code>my-svc.my-namespace.svc.cluster.local</code>”这条 DNS 记录，就可以访问到名叫 <code>my-svc</code> 的 <code>Service</code> 所代理的某一个 <code>Pod</code>。</li></ul><p><code>Service DNS</code> 下两种处理方法</p><blockquote><p><code>Normal Service</code>。这种情况下，你访问“my-svc.my-namespace.svc.cluster.local”解析到的，正是 my-svc 这个 Service 的 VIP，后面的流程就跟 VIP 方式一致了。
<code>Headless Service</code>。这种情况下，你访问“my-svc.my-namespace.svc.cluster.local”解析到的，直接就是 my-svc 代理的某一个 Pod 的 IP 地址。可以看到，这里的区别在于，Headless Service 不需要分配一个 VIP，而是可以直接以 DNS 记录的方式解析出被代理 Pod 的 IP 地址。</p></blockquote><p>Headless Service Yaml</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>port</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>web</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>clusterIP</span>: <span style=color:#ae81ff>None</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span></code></pre></div><p>StatefulSet Yaml</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>StatefulSet</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>web</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#75715e># 多了这个 ServiceName 就是告诉 StatefulSet 控制器，在执行控制循环（Control Loop）的时候，请使用 nginx 这个 Headless Service 来保证 Pod 的“可解析身份”。</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>serviceName</span>: <span style=color:#e6db74>&#34;nginx&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.9.1</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#ae81ff>web</span>
</span></span></code></pre></div><p>，对于“有状态应用”实例的访问，你必须使用 <code>DNS 记录</code>或者 <code>hostname</code> 的方式，而绝不应该直接访问这些 <code>Pod</code> 的 IP 地址。</p><h2 id=存储状态>存储状态</h2><p><code>StatefulSet</code> 存储状态的管理机制，主要使用的是一个叫做 <code>Persistent Volume Claim</code> 功能。</p><p>要在一个 Pod 里面声明 Volume，只要在 Pod 里加上 <code>spec.volumes</code> 字段，然后就可以在这个字段里面定义一个具体的类型的 <code>Volume</code>。比如 <code>hostPath</code>。</p><p><code>Kubernetes</code> 项目引入了一组叫作 <code>Persistent Volume Claim</code>（PVC）和 <code>Persistent Volume</code>（PV）的 API 对象，大大降低了用户声明和使用持久化 <code>Volume</code> 的门槛。</p><p>使用PVC的两步：</p><ul><li>定义一个 <code>PVC</code>，声明想要的 <code>Volume</code> 属性</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PersistentVolumeClaim</span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pv-claim</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>accessModes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>ReadWriteOnce</span> <span style=color:#75715e># 挂载方式：可读写，并且只能被挂载在一个节点上，非多个节点共享</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>storage</span>: <span style=color:#ae81ff>1Gi </span> <span style=color:#75715e>#存储大小</span>
</span></span></code></pre></div><ul><li>在应用 <code>POD</code> 中，使用这个 <code>PVC</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pv-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pv-container</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#34;http-server&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>mountPath</span>: <span style=color:#e6db74>&#34;/usr/share/nginx/html&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pv-storage</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pv-storage</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>persistentVolumeClaim</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>claimName</span>: <span style=color:#ae81ff>pv-claim</span> <span style=color:#75715e># 指定上面的PVC的名字</span>
</span></span></code></pre></div><p>从上面来看，这个 <code>Volume</code> 又从何而来呢？（运维人员维护的 <code>PV</code>）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># 这个 PV 对象的 spec.rbd 字段，正是我们前面介绍过的 Ceph RBD Volume 的详细定义。而且，它还声明了这个 PV 的容量是 10 GiB。这样，Kubernetes 就会为我们刚刚创建的 PVC 对象绑定这个 PV</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PersistentVolume</span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pv-volume</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>type</span>: <span style=color:#ae81ff>local</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>capacity</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>storage</span>: <span style=color:#ae81ff>10Gi</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>accessModes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>ReadWriteOnce</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>rbd</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>monitors</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 使用 kubectl get pods -n rook-ceph 查看 rook-ceph-mon- 开头的 POD IP 即可得下面的列表</span>
</span></span><span style=display:flex><span>    - <span style=color:#e6db74>&#39;10.16.154.78:6789&#39;</span>
</span></span><span style=display:flex><span>    - <span style=color:#e6db74>&#39;10.16.154.82:6789&#39;</span>
</span></span><span style=display:flex><span>    - <span style=color:#e6db74>&#39;10.16.154.83:6789&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>pool</span>: <span style=color:#ae81ff>kube</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>foo</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>fsType</span>: <span style=color:#ae81ff>ext4</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>readOnly</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>user</span>: <span style=color:#ae81ff>admin</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>keyring</span>: <span style=color:#ae81ff>/etc/ceph/keyring</span>
</span></span></code></pre></div><p>所以 <code>Kubernetes</code> 中的 <code>PVC</code> 和 <code>PV</code> 的设计，类似于 &ldquo;接口&rdquo; 和 &ldquo;实现&rdquo; 的思想，这种解耦，避免了暴露系统更多的细节，也是职责的分离，更容易定位问题</p><h2 id=statefulset-的工作原理>StatefulSet 的工作原理</h2><ul><li><code>StatefulSet</code> 控制器直接管理的是 <code>POD</code></li><li><code>Kubernetes</code> 通过 <code>Headless Service</code> 为这些有编号的 <code>POD</code>。在 <code>DNS</code> 服务器众生成同样带有编号的 <code>DNS纪录</code>。只要 <code>StatefulSet</code> 能够保证这些 <code>POD</code> 的名字编号不变，类似 &ldquo;<code>web-0.default.svc.cluster.local</code>&rdquo; 这样的 <code>DNS纪录</code> 就不会变，而这条纪录解析出来的<code>POD</code>的<code>IP</code>地址，会随着<code>后端的POD删除和再创建</code>而更新。</li><li><code>StatefulSet</code> 还为每个 <code>POD</code> 分配并创建一个同样编号的 <code>PVC</code>，这样 <code>Kubernetes</code> 可以通过 <code>Persistent Volume</code> 机制为这个 <code>PVC</code> 绑定对应的 <code>PV</code>，保证一个<code>POD</code>都有一个独立的 <code>Volume</code>（即使<code>POD</code>被删除，但是对应的 <code>PVC</code> 和 <code>PV</code> 保留下来，重新创建<code>POD</code>的时候，还会找回来，数据还存在）</li></ul><h1 id=容器化守护进程的意义-daemonset>容器化守护进程的意义 DaemonSet</h1><p><code>DaemonSet</code> 主要的作用: 在<code>Kubernetes</code>集群里运行一个 <code>Daemon Pod</code>,这个<code>Pod</code>三个特征</p><ul><li>每个<code>Kubernetes</code>节点都会运行一个这样的<code>POD</code></li><li>每个节点上只有一个这样的 <code>Pod</code> 实例</li><li>当有新的节点加入 <code>Kuberntes</code> 集群后，该 <code>Pod</code> 会自动的在新的节点上被创建出来，而当旧节点被删除后, 它上面的 Pod 也会相应地被回收掉。</li></ul><blockquote><p>eg：</p><ul><li>网络插件的 Agent 组件，必须运行在每个节点上，用来处理容器的网络</li><li>存储插件 Agent 组件，必须运行在每个节点上，用来挂载远程存储目录，操作容器的 Volume 目录</li><li>监控组件 以及 日志组件，也是一样，负责节点的监控信息和日志收集</li></ul></blockquote><p>跟其他编排不一样，DaemonSet 开始运行的时机，很多时候比整个 Kubernetes 集群出现的还要早。比如容器网络组件，在所有的 Worker节点状态都是 NotReady。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># fluentd-elasticsearch 镜像POD， 通过 Fluentd 将 Docker 容器日志转发到 ES 内。</span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>DaemonSet</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>fluentd-elasticsearch</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>kube-system</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>k8s-app</span>: <span style=color:#ae81ff>fluentd-logging</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>fluentd-elasticsearch</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>fluentd-elasticsearch</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>tolerations</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>key</span>: <span style=color:#ae81ff>node-role.kubernetes.io/master</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>effect</span>: <span style=color:#ae81ff>NoSchedule</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>fluentd-elasticsearch</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>k8s.gcr.io/fluentd-elasticsearch:1.20</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>limits</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>memory</span>: <span style=color:#ae81ff>200Mi</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>cpu</span>: <span style=color:#ae81ff>100m</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>memory</span>: <span style=color:#ae81ff>200Mi</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 挂载了两个hostPath类型 的 Volume    </span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>varlog</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/var/log</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Docker 容器里应用的日志，默认会保存在宿主机的 /var/lib/docker/containers/{{. 容器 ID}}/{{. 容器 ID}}-json.log 文件里，所以这个目录正是 fluentd 的搜集目标  </span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>varlibdockercontainers</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/var/lib/docker/containers</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>readOnly</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>terminationGracePeriodSeconds</span>: <span style=color:#ae81ff>30</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>varlog</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>hostPath</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/var/log</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>varlibdockercontainers</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>hostPath</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/var/lib/docker/containers</span>
</span></span></code></pre></div><p><code>DaemonSet Controller</code>，首先从 <code>Etcd</code> 里获取所有的 <code>Node</code> 列表，然后遍历所有的 <code>Node</code>。这时就会去检查这个<code>Node</code>上是不是已经存在携带了 <code>name=fluentd-elasticsearch</code> 的 <code>POD</code> 在运行了</p><ul><li>没有这个POD，则创建一个新的 POD</li><li>有这种POD，数量 > 1, 删除多余的</li><li>正好一个，节点正常</li></ul><p><code>DaemonSet</code> 会自动加上 <code>tolerations</code>字段</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>with-toleration</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#75715e># “容忍”所有被标记为 unschedulable“污点”的 Node；“容忍”的效果是允许调度。</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tolerations</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>key</span>: <span style=color:#ae81ff>node.kubernetes.io/unschedulable</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>operator</span>: <span style=color:#ae81ff>Exists</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>effect</span>: <span style=color:#ae81ff>NoSchedule</span>
</span></span></code></pre></div><p>在正常情况下，被标记了 unschedulable“污点”的 Node，是不会有任何 Pod 被调度上去的（effect: NoSchedule）。可是，DaemonSet 自动地给被管理的 Pod 加上了这个特殊的 Toleration，就使得这些 Pod 可以忽略这个限制，继而保证每个节点上都会被调度一个 Pod。当然，如果这个节点有故障的话，这个 Pod 可能会启动失败，而 DaemonSet 则会始终尝试下去，直到 Pod 启动成功。</p><h1 id=离线业务-job-与-cronjob>离线业务 Job 与 CronJob</h1><p>像在线业务诸如应用一类的，抽离了描述离线业务的API对象：Job</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>batch/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Job</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pi</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pi</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>resouer/ubuntu-bc </span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>command</span>: [<span style=color:#e6db74>&#34;sh&#34;</span>, <span style=color:#e6db74>&#34;-c&#34;</span>, <span style=color:#e6db74>&#34;echo &#39;scale=10000; 4*a(1)&#39; | bc -l &#34;</span>]
</span></span><span style=display:flex><span>      <span style=color:#f92672>restartPolicy</span>: <span style=color:#ae81ff>Never</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>backoffLimit</span>: <span style=color:#ae81ff>4</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>
</span></span><span style=display:flex><span>$ kubectl describe jobs/pi
</span></span><span style=display:flex><span>Name:             pi
</span></span><span style=display:flex><span>Namespace:        default
</span></span><span style=display:flex><span>Selector:         controller-uid<span style=color:#f92672>=</span>c2db599a-2c9d-11e6-b324-0209dc45a495
</span></span><span style=display:flex><span>Labels:           controller-uid<span style=color:#f92672>=</span>c2db599a-2c9d-11e6-b324-0209dc45a495
</span></span><span style=display:flex><span>                  job-name<span style=color:#f92672>=</span>pi
</span></span><span style=display:flex><span>Annotations:      &lt;none&gt;
</span></span><span style=display:flex><span>Parallelism:      <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>Completions:      <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>..
</span></span><span style=display:flex><span>Pods Statuses:    <span style=color:#ae81ff>0</span> Running / <span style=color:#ae81ff>1</span> Succeeded / <span style=color:#ae81ff>0</span> Failed
</span></span><span style=display:flex><span>Pod Template:
</span></span><span style=display:flex><span>  Labels:       controller-uid<span style=color:#f92672>=</span>c2db599a-2c9d-11e6-b324-0209dc45a495
</span></span><span style=display:flex><span>                job-name<span style=color:#f92672>=</span>pi
</span></span><span style=display:flex><span>  Containers:
</span></span><span style=display:flex><span>   ...
</span></span><span style=display:flex><span>  Volumes:              &lt;none&gt;
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  FirstSeen    LastSeen    Count    From            SubobjectPath    Type        Reason            Message
</span></span><span style=display:flex><span>  ---------    --------    -----    ----            -------------    --------    ------            -------
</span></span><span style=display:flex><span>  1m           1m          <span style=color:#ae81ff>1</span>        <span style=color:#f92672>{</span>job-controller <span style=color:#f92672>}</span>                Normal      SuccessfulCreate  Created pod: pi-rq5rl
</span></span></code></pre></div><p>这个 Job 对象在创建后，它的 Pod 模板，被自动加上了一个 controller-uid=&lt; 一个随机字符串 > 这样的 Label。而这个 Job 对象本身，则被自动加上了这个 Label 对应的 Selector，从而 保证了 Job 与它所管理的 Pod 之间的匹配关系。而 Job Controller 之所以要使用这种携带了 UID 的 Label，就是为了避免不同 Job 对象所管理的 Pod 发生重合。</p><p>如果作业失败了怎么办？</p><p>定义了 restartPolicy=Never，那么离线作业失败后 Job Controller 就会不断地尝试创建一个新 Pod
我们就在 Job 对象的 spec.backoffLimit 字段里定义了重试次数为 4（即，backoffLimit=4），而这个字段的默认值是 6。
定义的 restartPolicy=OnFailure，那么离线作业失败后，Job Controller 就不会去尝试创建新的 Pod。但是，它会不断地尝试重启 Pod 里的容器</p><p>Job 对象中，并行作业的控制方法</p><ul><li>1、spec.parallelism，它定义的是一个 Job 在任意时间最多可以启动多少个 Pod 同时运行；</li><li>2、spec.completions，它定义的是 Job 至少要完成的 Pod 数目，即 Job 的最小完成数。</li></ul><h2 id=常用的使用-job对象的方法>常用的使用 Job对象的方法</h2><ul><li>外部管理器 + Job模板 （sed）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>batch/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Job</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#75715e># 带遍历替换</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>process-item-$ITEM</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>jobgroup</span>: <span style=color:#ae81ff>jobexample</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>jobexample</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>jobgroup</span>: <span style=color:#ae81ff>jobexample</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>c</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>busybox</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>command</span>: [<span style=color:#e6db74>&#34;sh&#34;</span>, <span style=color:#e6db74>&#34;-c&#34;</span>, <span style=color:#e6db74>&#34;echo Processing item $ITEM &amp;&amp; sleep 5&#34;</span>]
</span></span><span style=display:flex><span>      <span style=color:#f92672>restartPolicy</span>: <span style=color:#ae81ff>Never</span>
</span></span></code></pre></div><ul><li><p>拥有固定任务数目的并行Job</p></li><li><p>指定并行度（parallelism），但不设置固定的 completions 的值。</p></li></ul><h2 id=cronjob-对象>CronJob 对象</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>batch/v1beta1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>CronJob</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hello</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#75715e># cron </span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>schedule</span>: <span style=color:#e6db74>&#34;*/1 * * * *&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>jobTemplate</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>          - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hello</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>image</span>: <span style=color:#ae81ff>busybox</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>args</span>:
</span></span><span style=display:flex><span>            - <span style=color:#ae81ff>/bin/sh</span>
</span></span><span style=display:flex><span>            - -<span style=color:#ae81ff>c</span>
</span></span><span style=display:flex><span>            - <span style=color:#ae81ff>date; echo Hello from the Kubernetes cluster</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>restartPolicy</span>: <span style=color:#ae81ff>OnFailure</span>
</span></span></code></pre></div><p>CronJob 是专门管理 Job 对象的控制其。只不过它的创建和删除Job依据是根据
schedule 字段来定义的。</p><p>在 定时任务的时候，可能有任务未执行完毕，就下面的Pod启动</p><ul><li>concurrencyPolicy=Allow，这也是默认情况，这意味着这些 Job 可以同时存在；</li><li>concurrencyPolicy=Forbid，这意味着不会创建新的 Pod，该创建周期被跳过；</li><li>concurrencyPolicy=Replace，这意味着新产生的 Job 会替换旧的、没有执行完的 Job。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># startingDeadlineSeconds=200，意味着在过去 200 s 里，如果 miss 的数目达到了 100 次，那么这个 Job 就不会被创建执行了</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>spec.startingDeadlineSeconds 时间窗口</span>
</span></span></code></pre></div></div></article><div class=blog-post-comments><div id=disqus_thread><script type=text/javascript>(function(){var t,e=document.createElement('script');e.type='text/javascript',e.async=!0,t='pinkhello',e.src='//'+t+'.disqus.com/embed.js',(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/categories>Category</a></li><li><a href=/tags>Tag</a></li><li><a href=/index.xml>Rss</a></li><li><a href=/jobs>Job</a></li></ul></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f" aria-label=Facebook><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f&text=%e5%9b%9e%e6%9c%9bK8S%20%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8eKubernetes%e4%bd%9c%e4%b8%9a%e7%ae%a1%e7%90%86" aria-label=Twitter><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f&title=%e5%9b%9e%e6%9c%9bK8S%20%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8eKubernetes%e4%bd%9c%e4%b8%9a%e7%ae%a1%e7%90%86" aria-label=Linkedin><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f&is_video=false&description=%e5%9b%9e%e6%9c%9bK8S%20%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8eKubernetes%e4%bd%9c%e4%b8%9a%e7%ae%a1%e7%90%86" aria-label=Pinterest><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=%e5%9b%9e%e6%9c%9bK8S%20%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8eKubernetes%e4%bd%9c%e4%b8%9a%e7%ae%a1%e7%90%86&body=Check out this article: https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f" aria-label=Email><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f&title=%e5%9b%9e%e6%9c%9bK8S%20%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8eKubernetes%e4%bd%9c%e4%b8%9a%e7%ae%a1%e7%90%86" aria-label=Pocket><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f&title=%e5%9b%9e%e6%9c%9bK8S%20%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8eKubernetes%e4%bd%9c%e4%b8%9a%e7%ae%a1%e7%90%86" aria-label=reddit><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f&name=%e5%9b%9e%e6%9c%9bK8S%20%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8eKubernetes%e4%bd%9c%e4%b8%9a%e7%ae%a1%e7%90%86&description=Pod%20pod%20%e6%98%af%20Kubernetes%20%e9%a1%b9%e7%9b%ae%e7%9a%84%e6%9c%80%e5%b0%8f%e7%9a%84%20API%20%e5%af%b9%e8%b1%a1%ef%bc%8c%e5%8e%9f%e5%ad%90%e8%b0%83%e5%ba%a6%e5%8d%95%e4%bd%8d.%0a%e5%81%87%e8%ae%be%20%26ldquo%3b%e5%ae%b9%e5%99%a8%e7%9a%84%e6%9c%ac%e8%b4%a8%e6%98%af%e8%bf%9b%e7%a8%8b%26rdquo%3b%ef%bc%8c%e5%ae%b9%e5%99%a8%e9%95%9c%e5%83%8f%e5%b0%b1%e6%98%af%20exe%20%e5%ae%89%e8%a3%85%e5%8c%85%2c%20kubernetes%20%e6%98%af%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%0aPod%20%e6%9c%80%e9%87%8d%e8%a6%81%e7%9a%84%e4%b8%80%e4%b8%aa%e4%ba%8b%e5%ae%9e%e6%98%af%e4%b8%80%e4%b8%aa%e9%80%bb%e8%be%91%e6%a6%82%e5%bf%b5%e3%80%82%e5%ae%83%e5%af%b9%e4%ba%8e%20Kubernetes%20%e6%9c%80%e6%a0%b8%e5%bf%83%e7%9a%84%e6%84%8f%e4%b9%89%e6%98%af%20%e5%ae%b9%e5%99%a8%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e3%80%82Kubernetes%20%e7%9c%9f%e6%ad%a3%e5%a4%84%e7%90%86%e7%9a%84%e8%bf%98%e6%98%af%e5%ae%bf%e4%b8%bb%e6%9c%ba%e4%b8%8a%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e4%b8%8a%e7%9a%84%20Linux%20%e5%ae%b9%e5%99%a8%e7%9a%84%20Namespace%20%e5%92%8c%20Cgroups%ef%bc%8c%e8%80%8c%e4%b8%8d%e6%98%af%e4%b8%80%e4%b8%aa%e6%89%80%e8%b0%93%e7%9a%84%20Pod%20%e8%be%b9%e7%95%8c%e5%92%8c%e9%9a%94%e7%a6%bb%e7%8e%af%e5%a2%83%e3%80%82%0aPod%20%e5%85%b6%e5%ae%9e%e6%98%af%e4%b8%80%e7%bb%84%e5%85%b1%e4%ba%ab%e4%ba%86%e6%9f%90%e4%ba%9b%e8%b5%84%e6%ba%90%e7%9a%84%e5%ae%b9%e5%99%a8%e3%80%82Pod%20%e9%87%8c%e9%9d%a2%e6%89%80%e6%9c%89%e7%9a%84%e5%ae%b9%e5%99%a8%ef%bc%8c%e5%85%b1%e4%ba%ab%e7%9a%84%e5%90%8c%e4%b8%80%e4%b8%aa%20Network%20Namespace%ef%bc%8c%e5%b9%b6%e4%b8%94%e5%8f%af%e4%bb%a5%e5%a3%b0%e6%98%8e%e5%85%b1%e4%ba%ab%e5%90%8c%e4%b8%80%e4%b8%aa%20Volume.%0aKubernetes%20%e9%a1%b9%e7%9b%ae%e5%86%85%e9%83%a8%ef%bc%8cPod%20%e5%ae%9e%e7%8e%b0%e9%9c%80%e8%a6%81%e4%bd%bf%e7%94%a8%e4%b8%80%e4%b8%aa%e4%b8%ad%e9%97%b4%e5%ae%b9%e5%99%a8%ef%bc%8c%e8%bf%99%e4%b8%aa%e5%ae%b9%e5%99%a8%e5%8f%ab%e5%81%9a%20Infra%20%e5%ae%b9%e5%99%a8%ef%bc%8c%e5%9c%a8%20Pod%20%e4%b8%ad%ef%bc%8cInfra%20%e5%ae%b9%e5%99%a8%e6%b0%b8%e8%bf%9c%e9%83%bd%e6%98%af%e7%ac%ac%e4%b8%80%e4%b8%aa%e8%a2%ab%e5%88%9b%e5%bb%ba%e7%9a%84%e5%ae%b9%e5%99%a8%ef%bc%8c%e8%80%8c%e5%85%b6%e4%bb%96%e7%94%a8%e6%88%b7%e5%ae%9a%e4%b9%89%e7%9a%84%e5%ae%b9%e5%99%a8%ef%bc%8c%e5%88%99%e9%80%9a%e8%bf%87%20Join%20Network%20Namespace%20%e7%9a%84%e6%96%b9%e5%bc%8f%ef%bc%8c%e4%b8%8e%20Infra%20%e5%ae%b9%e5%99%a8%e5%85%b3%e8%81%94%e5%9c%a8%e4%b8%80%e8%b5%b7%e3%80%82%0asidecar%20%e5%85%b8%e5%9e%8b%e7%9a%84%e4%be%8b%e5%ad%90%ef%bc%9aWAR%20%e5%8c%85%e5%92%8c%20Web%20%e6%9c%8d%e5%8a%a1%e5%99%a8%20POD%e5%90%8e%ef%bc%8c%e5%b0%86%20WAR%20%e5%8c%85%e5%92%8c%20Tomcat%20%e5%88%86%e5%88%ab%e5%81%9a%e6%88%90%e9%95%9c%e5%83%8f%ef%bc%8c%e5%8f%af%e4%bb%a5%e6%8a%8a%e4%bb%96%e4%bb%ac%e5%ae%b9%e5%99%a8%e7%bb%93%e5%90%88%e5%9c%a8%e4%b8%80%e8%b5%b7%0a---%20apiVersion%3a%20v1%20kind%3a%20Pod%20metadata%3a%20name%3a%20javaweb-2%20spec%3a%20%23%20%e5%90%af%e5%8a%a8%e5%90%8e%e5%81%9a%e4%ba%86%e4%b8%80%e4%bb%b6%e4%ba%8b%20%e6%8a%8a%e5%ba%94%e7%94%a8%e7%9a%84WAR%e5%8c%85%e6%8b%b7%e8%b4%9d%e5%88%b0%20%2fapp%e7%9b%ae%e5%bd%95%e4%b8%ad%ef%bc%8c%e5%90%8e%e9%80%80%e5%87%ba%20initContainers%3a%20-%20image%3a%20sample-war%3av2%20name%3a%20war%20command%3a%20%5b%26%2334%3bcp%26%2334%3b%2c%20%26%2334%3b%2fsample." aria-label=Tumblr><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fpinkhello.cc%2fposts%2f20-%25E5%259B%259E%25E6%259C%259Bk8s-%25E5%25AE%25B9%25E5%2599%25A8%25E7%25BC%2596%25E6%258E%2592%25E4%25B8%258Ekubernetes%25E4%25BD%259C%25E4%25B8%259A%25E7%25AE%25A1%25E7%2590%2586%2f&t=%e5%9b%9e%e6%9c%9bK8S%20%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8eKubernetes%e4%bd%9c%e4%b8%9a%e7%ae%a1%e7%90%86" aria-label="Hacker News"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu-toggle class=icon href=# onclick="return $('#nav-footer').toggle(),!1" aria-label=Menu><i class="fas fa-bars fa-lg" aria-hidden=true></i> Menu</a>
<a id=share-toggle class=icon href=# onclick="return $('#share-footer').toggle(),!1" aria-label=Share><i class="fas fa-share-alt fa-lg" aria-hidden=true></i> share</a>
<a id=top style=display:none class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast')" aria-label="Top of Page"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i> Top</a></div></div></div><footer id=footer><div class=footer-left>Copyright &copy; 2022 pinkhello</div><div class=footer-right><nav><ul><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/categories>Category</a></li><li><a href=/tags>Tag</a></li><li><a href=/index.xml>Rss</a></li><li><a href=/jobs>Job</a></li></ul></nav></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
<script src=/js/code-copy.js></script>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></html>