<!doctype html><html lang=en-us><head><link rel=preload href=/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><script type=text/javascript src=https://latest.cactus.chat/cactus.js></script>
<link rel=stylesheet href=https://latest.cactus.chat/style.css type=text/css><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>JVM内存结构JMM | pinkhello</title><link rel=canonical href=https://pinkhello.cc/posts/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84jmm/><meta name=description content="👷Hey! 我是 **pinkhello**，💻 一名后端程序员。**重要提示**: 在您阅读文章并评论之前，请先认真阅读[**评论承诺**](http://pinkhello.cc/promise)。"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="JVM内存结构JMM"><meta property="og:description" content="JVM 内存模型 从JVM的官方文档上可以看见，JVM的内存结构主要包含三块: 堆内存、方法区、栈
堆中又分 新生代 和 老年代, 新生代包含 Eden空间、From Survivor空间、To Survivor空间，也是线程共享的区域
方法区（非堆区）存储的 类信息、常量、静态变量等数据，是线程共享的区域，
栈 分为 本地方法栈 和 JVM虚拟机栈，还有个程序计数器 这三个都是线程私有的
Java Heap Java Heap 是 JVM 虚拟机管理的内存最大的一块，Java Heap 被所有的线程共享的内存区域，几乎所有的对象都在这里分配，也是 GC 管理的主要区域 Java Heap 是在物理上不连续的内存空间，只要逻辑上连续即可。
Method Area Method Area（非堆） 和 Java Heap 一样，是🧍各个线程共享的内存区域，用于存储已经被虚拟机加载的 类信息、常量、静态变量、即使编译器编译的代码等等
Program Counter Register Program Counter Register 程序计数器，较小的内存空间，是当前线程锁执行的字节码的行号指示器（唯一一个没有OOM的区域）
JVM Stacks JVM Stacks 也是线程私有的，它的生命周期和线程相同，虚拟机栈描述的 Java 方法执行的内存模型： 创建栈帧 Stack frame 用于存储 局部变量表、操作栈、动态链接、方法出口 等信息 每次方法被调用直至完成，都对应着一个栈帧在虚拟机栈中的入栈和出栈过程。
JVM 两种异常：
线程请求栈深度大于虚拟机允许的深度 StackOverflowError
JVM栈一般动态扩展的，如果无法申请足够的内存，会抛 OutOfMemoryError"><meta property="og:type" content="article"><meta property="og:url" content="https://pinkhello.cc/posts/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84jmm/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-04T01:17:28+08:00"><meta property="article:modified_time" content="2022-05-04T01:17:28+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="JVM内存结构JMM"><meta name=twitter:description content="JVM 内存模型 从JVM的官方文档上可以看见，JVM的内存结构主要包含三块: 堆内存、方法区、栈
堆中又分 新生代 和 老年代, 新生代包含 Eden空间、From Survivor空间、To Survivor空间，也是线程共享的区域
方法区（非堆区）存储的 类信息、常量、静态变量等数据，是线程共享的区域，
栈 分为 本地方法栈 和 JVM虚拟机栈，还有个程序计数器 这三个都是线程私有的
Java Heap Java Heap 是 JVM 虚拟机管理的内存最大的一块，Java Heap 被所有的线程共享的内存区域，几乎所有的对象都在这里分配，也是 GC 管理的主要区域 Java Heap 是在物理上不连续的内存空间，只要逻辑上连续即可。
Method Area Method Area（非堆） 和 Java Heap 一样，是🧍各个线程共享的内存区域，用于存储已经被虚拟机加载的 类信息、常量、静态变量、即使编译器编译的代码等等
Program Counter Register Program Counter Register 程序计数器，较小的内存空间，是当前线程锁执行的字节码的行号指示器（唯一一个没有OOM的区域）
JVM Stacks JVM Stacks 也是线程私有的，它的生命周期和线程相同，虚拟机栈描述的 Java 方法执行的内存模型： 创建栈帧 Stack frame 用于存储 局部变量表、操作栈、动态链接、方法出口 等信息 每次方法被调用直至完成，都对应着一个栈帧在虚拟机栈中的入栈和出栈过程。
JVM 两种异常：
线程请求栈深度大于虚拟机允许的深度 StackOverflowError
JVM栈一般动态扩展的，如果无法申请足够的内存，会抛 OutOfMemoryError"><link rel=stylesheet href=https://pinkhello.cc/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="><link rel=stylesheet href=https://pinkhello.cc/css/pinkhello.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://pinkhello.cc/images/favicon.ico><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','G-M2FXWC325L','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class="max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a>
<a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a>
<a id=top-icon-tablet href=# onclick="$('html, body').animate({scrollTop:0},'fast')" style=display:none aria-label="Top of Page"><i class="fas fa-chevron-up fa-lg"></i></a>
<span id=menu><span id=nav><ul><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/categories>Category</a></li><li><a href=/tags>Tag</a></li><li><a href=/index.xml>Rss</a></li><li><a href=/jobs>Job</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=https://pinkhello.cc/posts/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/ aria-label=Previous><i class="fas fa-chevron-left" aria-hidden=true onmouseover="$('#i-prev').toggle()" onmouseout="$('#i-prev').toggle()"></i></a></li><li><a class=icon href=https://pinkhello.cc/posts/systemd%E6%9C%8D%E5%8A%A1%E7%AC%94%E8%AE%B0/ aria-label=Next><i class="fas fa-chevron-right" aria-hidden=true onmouseover="$('#i-next').toggle()" onmouseout="$('#i-next').toggle()"></i></a></li><li><a class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast')" aria-label="Top of Page"><i class="fas fa-chevron-up" aria-hidden=true onmouseover="$('#i-top').toggle()" onmouseout="$('#i-top').toggle()"></i></a></li><li><a class=icon href=# aria-label=Share><i class="fas fa-share-alt" aria-hidden=true onmouseover="$('#i-share').toggle()" onmouseout="$('#i-share').toggle()" onclick="return $('#share').toggle(),!1"></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f" aria-label=Facebook><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f&text=JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84JMM" aria-label=Twitter><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f&title=JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84JMM" aria-label=Linkedin><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f&is_video=false&description=JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84JMM" aria-label=Pinterest><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84JMM&body=Check out this article: https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f" aria-label=Email><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f&title=JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84JMM" aria-label=Pocket><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f&title=JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84JMM" aria-label=reddit><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f&name=JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84JMM&description=JVM%20%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%20%e4%bb%8eJVM%e7%9a%84%e5%ae%98%e6%96%b9%e6%96%87%e6%a1%a3%e4%b8%8a%e5%8f%af%e4%bb%a5%e7%9c%8b%e8%a7%81%ef%bc%8cJVM%e7%9a%84%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84%e4%b8%bb%e8%a6%81%e5%8c%85%e5%90%ab%e4%b8%89%e5%9d%97%3a%20%e5%a0%86%e5%86%85%e5%ad%98%e3%80%81%e6%96%b9%e6%b3%95%e5%8c%ba%e3%80%81%e6%a0%88%0a%e5%a0%86%e4%b8%ad%e5%8f%88%e5%88%86%20%e6%96%b0%e7%94%9f%e4%bb%a3%20%e5%92%8c%20%e8%80%81%e5%b9%b4%e4%bb%a3%2c%20%e6%96%b0%e7%94%9f%e4%bb%a3%e5%8c%85%e5%90%ab%20Eden%e7%a9%ba%e9%97%b4%e3%80%81From%20Survivor%e7%a9%ba%e9%97%b4%e3%80%81To%20Survivor%e7%a9%ba%e9%97%b4%ef%bc%8c%e4%b9%9f%e6%98%af%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab%e7%9a%84%e5%8c%ba%e5%9f%9f%0a%e6%96%b9%e6%b3%95%e5%8c%ba%ef%bc%88%e9%9d%9e%e5%a0%86%e5%8c%ba%ef%bc%89%e5%ad%98%e5%82%a8%e7%9a%84%20%e7%b1%bb%e4%bf%a1%e6%81%af%e3%80%81%e5%b8%b8%e9%87%8f%e3%80%81%e9%9d%99%e6%80%81%e5%8f%98%e9%87%8f%e7%ad%89%e6%95%b0%e6%8d%ae%ef%bc%8c%e6%98%af%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab%e7%9a%84%e5%8c%ba%e5%9f%9f%ef%bc%8c%0a%e6%a0%88%20%e5%88%86%e4%b8%ba%20%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95%e6%a0%88%20%e5%92%8c%20JVM%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88%ef%bc%8c%e8%bf%98%e6%9c%89%e4%b8%aa%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8%20%e8%bf%99%e4%b8%89%e4%b8%aa%e9%83%bd%e6%98%af%e7%ba%bf%e7%a8%8b%e7%a7%81%e6%9c%89%e7%9a%84%0aJava%20Heap%20Java%20Heap%20%e6%98%af%20JVM%20%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%ae%a1%e7%90%86%e7%9a%84%e5%86%85%e5%ad%98%e6%9c%80%e5%a4%a7%e7%9a%84%e4%b8%80%e5%9d%97%ef%bc%8cJava%20Heap%20%e8%a2%ab%e6%89%80%e6%9c%89%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab%e7%9a%84%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%ef%bc%8c%e5%87%a0%e4%b9%8e%e6%89%80%e6%9c%89%e7%9a%84%e5%af%b9%e8%b1%a1%e9%83%bd%e5%9c%a8%e8%bf%99%e9%87%8c%e5%88%86%e9%85%8d%ef%bc%8c%e4%b9%9f%e6%98%af%20GC%20%e7%ae%a1%e7%90%86%e7%9a%84%e4%b8%bb%e8%a6%81%e5%8c%ba%e5%9f%9f%20Java%20Heap%20%e6%98%af%e5%9c%a8%e7%89%a9%e7%90%86%e4%b8%8a%e4%b8%8d%e8%bf%9e%e7%bb%ad%e7%9a%84%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%ef%bc%8c%e5%8f%aa%e8%a6%81%e9%80%bb%e8%be%91%e4%b8%8a%e8%bf%9e%e7%bb%ad%e5%8d%b3%e5%8f%af%e3%80%82%0aMethod%20Area%20Method%20Area%ef%bc%88%e9%9d%9e%e5%a0%86%ef%bc%89%20%e5%92%8c%20Java%20Heap%20%e4%b8%80%e6%a0%b7%ef%bc%8c%e6%98%af%f0%9f%a7%8d%e5%90%84%e4%b8%aa%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab%e7%9a%84%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%ef%bc%8c%e7%94%a8%e4%ba%8e%e5%ad%98%e5%82%a8%e5%b7%b2%e7%bb%8f%e8%a2%ab%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%8a%a0%e8%bd%bd%e7%9a%84%20%e7%b1%bb%e4%bf%a1%e6%81%af%e3%80%81%e5%b8%b8%e9%87%8f%e3%80%81%e9%9d%99%e6%80%81%e5%8f%98%e9%87%8f%e3%80%81%e5%8d%b3%e4%bd%bf%e7%bc%96%e8%af%91%e5%99%a8%e7%bc%96%e8%af%91%e7%9a%84%e4%bb%a3%e7%a0%81%e7%ad%89%e7%ad%89%0aProgram%20Counter%20Register%20Program%20Counter%20Register%20%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8%ef%bc%8c%e8%be%83%e5%b0%8f%e7%9a%84%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%ef%bc%8c%e6%98%af%e5%bd%93%e5%89%8d%e7%ba%bf%e7%a8%8b%e9%94%81%e6%89%a7%e8%a1%8c%e7%9a%84%e5%ad%97%e8%8a%82%e7%a0%81%e7%9a%84%e8%a1%8c%e5%8f%b7%e6%8c%87%e7%a4%ba%e5%99%a8%ef%bc%88%e5%94%af%e4%b8%80%e4%b8%80%e4%b8%aa%e6%b2%a1%e6%9c%89OOM%e7%9a%84%e5%8c%ba%e5%9f%9f%ef%bc%89%0aJVM%20Stacks%20JVM%20Stacks%20%e4%b9%9f%e6%98%af%e7%ba%bf%e7%a8%8b%e7%a7%81%e6%9c%89%e7%9a%84%ef%bc%8c%e5%ae%83%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%92%8c%e7%ba%bf%e7%a8%8b%e7%9b%b8%e5%90%8c%ef%bc%8c%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88%e6%8f%8f%e8%bf%b0%e7%9a%84%20Java%20%e6%96%b9%e6%b3%95%e6%89%a7%e8%a1%8c%e7%9a%84%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%ef%bc%9a%20%e5%88%9b%e5%bb%ba%e6%a0%88%e5%b8%a7%20Stack%20frame%20%e7%94%a8%e4%ba%8e%e5%ad%98%e5%82%a8%20%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e8%a1%a8%e3%80%81%e6%93%8d%e4%bd%9c%e6%a0%88%e3%80%81%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e3%80%81%e6%96%b9%e6%b3%95%e5%87%ba%e5%8f%a3%20%e7%ad%89%e4%bf%a1%e6%81%af%20%e6%af%8f%e6%ac%a1%e6%96%b9%e6%b3%95%e8%a2%ab%e8%b0%83%e7%94%a8%e7%9b%b4%e8%87%b3%e5%ae%8c%e6%88%90%ef%bc%8c%e9%83%bd%e5%af%b9%e5%ba%94%e7%9d%80%e4%b8%80%e4%b8%aa%e6%a0%88%e5%b8%a7%e5%9c%a8%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88%e4%b8%ad%e7%9a%84%e5%85%a5%e6%a0%88%e5%92%8c%e5%87%ba%e6%a0%88%e8%bf%87%e7%a8%8b%e3%80%82%0aJVM%20%e4%b8%a4%e7%a7%8d%e5%bc%82%e5%b8%b8%ef%bc%9a%0a%e7%ba%bf%e7%a8%8b%e8%af%b7%e6%b1%82%e6%a0%88%e6%b7%b1%e5%ba%a6%e5%a4%a7%e4%ba%8e%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%85%81%e8%ae%b8%e7%9a%84%e6%b7%b1%e5%ba%a6%20StackOverflowError%0aJVM%e6%a0%88%e4%b8%80%e8%88%ac%e5%8a%a8%e6%80%81%e6%89%a9%e5%b1%95%e7%9a%84%ef%bc%8c%e5%a6%82%e6%9e%9c%e6%97%a0%e6%b3%95%e7%94%b3%e8%af%b7%e8%b6%b3%e5%a4%9f%e7%9a%84%e5%86%85%e5%ad%98%ef%bc%8c%e4%bc%9a%e6%8a%9b%20OutOfMemoryError" aria-label=Tumblr><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f&t=JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84JMM" aria-label="Hacker News"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">JVM内存结构JMM</h1><div class=meta><div class=postdate><time datetime="2022-05-04 01:17:28 +0800 +0800" itemprop=datePublished>2022-05-04</time></div><div class=article-category><i class="fas fa-archive"></i>
<a class=category-link href=/categories/tech>Tech</a></div></div></header><div id=toc><nav id=TableOfContents><ul><li><a href=#jvm-内存模型>JVM 内存模型</a></li><li><a href=#gc垃圾回收器-gc算法>GC垃圾回收器 GC算法</a></li><li><a href=#垃圾分代回收算法>垃圾分代回收算法</a></li><li><a href=#垃圾回收器>垃圾回收器</a></li><li><a href=#jmm-java内存模型>JMM (Java内存模型)</a></li><li><a href=#jvm-g1-的内存模型>JVM G1 的内存模型</a></li><li><a href=#g1-回收过程>G1 回收过程</a></li><li><a href=#垃圾收集器的特点>垃圾收集器的特点</a></li></ul></nav></div><div class=content itemprop=articleBody><h2 id=jvm-内存模型>JVM 内存模型</h2><p>从JVM的官方文档上可以看见，JVM的内存结构主要包含三块: 堆内存、方法区、栈</p><p>堆中又分 新生代 和 老年代, 新生代包含 Eden空间、From Survivor空间、To Survivor空间，也是线程共享的区域</p><p>方法区（非堆区）存储的 类信息、常量、静态变量等数据，是线程共享的区域，</p><p>栈 分为 本地方法栈 和 JVM虚拟机栈，还有个程序计数器 这三个都是线程私有的</p><ul><li>Java Heap</li></ul><p>Java Heap 是 JVM 虚拟机管理的内存最大的一块，Java Heap 被所有的线程共享的内存区域，几乎所有的对象都在这里分配，也是 GC 管理的主要区域
Java Heap 是在物理上不连续的内存空间，只要逻辑上连续即可。</p><ul><li>Method Area</li></ul><p>Method Area（非堆） 和 Java Heap 一样，是🧍各个线程共享的内存区域，用于存储已经被虚拟机加载的 类信息、常量、静态变量、即使编译器编译的代码等等</p><ul><li>Program Counter Register</li></ul><p>Program Counter Register 程序计数器，较小的内存空间，是当前线程锁执行的字节码的行号指示器（唯一一个没有OOM的区域）</p><ul><li>JVM Stacks</li></ul><p>JVM Stacks 也是线程私有的，它的生命周期和线程相同，虚拟机栈描述的 Java 方法执行的内存模型： 创建栈帧 Stack frame 用于存储 局部变量表、操作栈、动态链接、方法出口 等信息
每次方法被调用直至完成，都对应着一个栈帧在虚拟机栈中的入栈和出栈过程。</p><p>JVM 两种异常：</p><ul><li><p>线程请求栈深度大于虚拟机允许的深度 StackOverflowError</p></li><li><p>JVM栈一般动态扩展的，如果无法申请足够的内存，会抛 OutOfMemoryError</p></li><li><p>Native Method Stacks</p></li></ul><p>Native Method Stacks 与 JVN Stacks 功能非常相似，本地方法栈是为虚拟机使用到 Native方法服务。</p><h2 id=gc垃圾回收器-gc算法>GC垃圾回收器 GC算法</h2><p>判断对象是否存活:</p><ul><li>引用计数</li><li>可达性分析</li></ul><p>Java堆内存被分代管理，分代也是为了快速方便的垃圾回收，针对不同的代，使用不同的回收算法方式</p><p>垃圾分代回收算法</p><ul><li>标记清除算法</li><li>复制算法</li><li>标记压缩算法</li></ul><h2 id=垃圾分代回收算法>垃圾分代回收算法</h2><ul><li>标记清除算法 Mark-Sweep，分为<code>标记``清除</code>两个阶段, 首先标记出所有需要回收的对象、后面统一回收掉被标记的对象。</li></ul><blockquote><p>特点</p><ul><li>效率问题，标记阶段、清除阶段的效率都不高</li><li>空间问题，标记清除之后产生大量的内存碎片，空间碎片太多</li></ul></blockquote><ul><li>复制算法 Copying，复制算法将内存容量划分成大小相等的凉快，每次只使用其中一块。当一块使用完毕，将存活的对象迁移到另外一块，然后将已经使用的全部清理掉。这种算法适合新生代</li></ul><blockquote><p>特点</p><ul><li>解决了内存碎片问题，但是代价是内存缩小到原来的一半</li><li>持续复制长时间生成的对象，效率低</li></ul></blockquote><ul><li><p>标记压缩算法 Mark-Compact，分为 <code>标记</code> <code>整理</code> 阶段，首先标记过程也是标记出需要清除的对象，后续是让所有的存活的对象向一端一端，然后清理边界以外的内存。</p></li><li><p>分代收集算法，为什么会有分代收集，Java堆分为新生代和老年代，且根据各个年代的特点选择合适的收集算法。新生代：绝大部分对象会很快死亡，只有少量存在，就选择复制算法。 老年代: 大部分对象都是存活很高，就可以选择 标记清理 或 标记整理 算法进行回收。</p></li></ul><h2 id=垃圾回收器>垃圾回收器</h2><ul><li>Serial 收集器, 一个线程去回收,会产生 STW。新生代、老年代都是串行, 新生代复制,老年代标记压缩</li><li>ParNew 收集器, 是 Serial收集器的多线程版本。新生代并行, 老年代串行, 新生代复制,老年代标记压缩</li><li>Parallel 收集器, 类似 ParNew收集器，更关注系统的吞吐量，可以通过参数打开自适应调节策略。新生代并行，老年代串行, 新生代复制,老年代标记压缩</li><li>Parallel Old 收集器，是 Parallel Scavenge 的老年代版本，使用多线程和标记整理算法， 新生代Parallel收集器，老年代并行, 新生代复制,老年代标记整理</li><li>CMS 收集器(Concurrent Mark Sweep), 以获取最短的回收停顿时间为目标的收集器，基于 标记清除 算法实现的<blockquote><p>总共4个步骤</p><ul><li>CMS initial mark 初始标记: 标记 GC Roots 能直接关联到的对象</li><li>CMS concurrent mark 并发标记: 进行 GC Roots Tracing 过程</li><li>CMS remark 重新标记: 修正并发标记期间, 因为程序继续运行而导致的标记产生变动的那一部分对象的标记记录, 这个阶段停顿时间比初始标记阶段稍长一些, 但远比并发标记时间短</li><li>CMS concurrent sweep 并发清除</li></ul><p>初始标记、重新标记，仍然需要 &ldquo;Stop The World&rdquo;，优点：并发收集，低停顿，缺点：大量空间碎片、并发阶段降低吞吐量</p></blockquote></li></ul><h2 id=jmm-java内存模型>JMM (Java内存模型)</h2><p>当今的计算机都是多处理器系统, 处理器通常是有多级缓存的，因为这些缓存李处理器更近可以存储一部分数据，所以缓存可以改善处理器获取数据的速度和减少对共享内存数据总线的占用。</p><p>Java 的并发采用的是共享内存模型, 所以 Java 线程之间的通信是由 Java 内存模型控制的，JMM 决定了一个线程对共享变量的写入何时对另一个线程可见。
JMM 定义了线程和主内存之间的关系： 线程间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存存储了该线程以 读/写 共享变量的副本（本地内存是JMM抽象概念，真实不存在）</p><p>JMM 三个特征:</p><ul><li>原子性 : 一个操作不能被打断，要么全部执行完毕，要么不执行<blockquote><p>基本数据类型访问大部分都是原子操作, 对于不是原子的，在多线程并发情况下是线程非安全的。</p></blockquote></li><li>可见性 : 一个线程对共享变量做了变化，其他线程立即能够感知到变换<blockquote><p>通过将工作内存中的变量修改后的值同步到主内存, 在读取变量前从主内存刷新最新的值到工作内存中，依赖主内存的方式实现可见行</p><p>要保证可见性 volatile 、synchronized 、Lock、final 等等也可以</p><ul><li>volatile 的特殊规则保证了 volatile 变量值修改后新值立刻同步到主内存, 每次使用 volatile 变量前都立即从主内存刷新, 所以 volatile 保证了多线程操作变量的可见性</li><li>synchronized 同步方法/同步块 开始时(Monitor Enter) 使用共享变量时候会从主内存刷新变量到功罪内存中，在 同步方法/同步快 结束时(Monitor Exit) 会将工作内存变量值同步到主内存中</li><li>Lock 使用 ReentrantLock(可重入锁)实现可见行, 在方法执行 lock.lock() 的是时候m 共享变量会从主内存刷新变量到工作内存中, 在 finally 代码块中执行 lock.unlock(), 将工作内存中变量值同步到主内存</li><li>final 关键字可见性指的是 final 修饰的变量，在构造函数一旦完成</li></ul></blockquote></li><li>有序性</li></ul><h2 id=jvm-g1-的内存模型>JVM G1 的内存模型</h2><p>G1 GC (Garbage First Garbage Collector) 垃圾优先垃圾回收器，它是短停顿的垃圾回收器，为了取代 CMS 。</p><p>G1 的内存模型，相对之前的模型，已经不进行物理分代了，采用逻辑分代，不再对连续内存进行区分 新生代(Eden,From Survivor、To Survivor) 和 老年代(Old区)</p><p><img src=/jvm/G1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png alt=G1内存模型></p><p>从图中可以看到, G1 将内存分成一个个的 Region, 一块Region(分区)在逻辑上依然分代, 分为四种: Eden(伊甸区), Old(老年代), Survivor(幸存区), Humongous(大对象，横跨多个连续的Region)。</p><p>内存回收以 Region 为基本单位, Region回收使用的是 复制算法, 所以不存在内存碎片化问题，整体上属于标记压缩算法, 通过复制算法处理后内存会被整齐(region通过回收后被规整)</p><p>G1 是一种带压缩的垃圾收集器，在回收老年代的分区的时候, 将存活的对象从一个分区拷贝到另一个可用的分区, 这个拷贝的过程实现了局部压缩. 每个分区的大小从 1M～32M 不等, 都是 2 的幂次方</p><p>特点:</p><ul><li>并发收集</li><li>压缩空间时间不会延长GC的暂停时间</li><li>更易观测GC的暂停时间</li><li>适合不需要实现很高吞吐量的场景</li></ul><h2 id=g1-回收过程>G1 回收过程</h2><p>G1 回收过程主要有三个步骤</p><ul><li>年轻代回收 yong gc</li><li>老年代并发标记 concurrent marking</li><li>混合回收过程 mixed gc</li></ul><blockquote><p>当年轻代的 Eden区 用尽时候，开始年轻代回收; 当堆内存使用达到一定的值(默认45%)时, 开始老年代并发标记; 标记完毕立刻执行混合回收过程。</p></blockquote><p><img src=/jvm/RemeberSet.png alt="remeber set"></p><p>G1: remember set 为了避免全局扫描, 解决跨代引用问题避免全局扫描</p><blockquote><ul><li>每个 region 都有自身对应的一个记忆集 RSet</li><li>每次引用类型数据写操作的时候，都会产生一个写屏障(Write Barrier)暂时的中断操作</li><li>然后检查将要写入的 引用指向的对象是否和该引用类型数据在不同的 region (其他收集器将会检查老年代对象是否引用新生代对象)</li><li>如果不同, 通过 CardTable 把相关引用信息记录到引用指向对象所在的 region 对象的 RSet 中</li><li>当进行垃圾回收时候, 在 GC Root 的枚举范围内加入 RSet，就可以保证不进行全局的对象的对象关系扫描</li></ul></blockquote><p>dirty card queue:</p><p>对于应用程序的引用赋值，如 obj1.field = obj2, JVM 会在之前和之后指向特殊的操作，在 dirty card queue 中入队以恶搞保存了对象引用信息的 card,
年轻代回收的时候, G1 会对 dirty card queue 中所有的 card 进行处理，用来更新 RSet，确保 RSet 实时准确的反应引用关系</p><ul><li><p>年轻代GC</p><ul><li>并行的、独占式的 (STW) 来及回收, 会发生对象的代晋升, 将会把对象放入 Survivor 或者老年代</li><li>当Eden区内存空间耗尽时候, 会启动一次年轻代垃圾回收，同时回收 Survivor 区<blockquote><ul><li>G1 Young GC 的时候，先停止程序线程(STW), G1 创建 回收集 (Collection Set, 需要被回收的内存分段集合，包含了 Eden区 和 Survivor区 所有的内存分段)</li><li>第一阶段, 扫描 GC Roots, GC Roots 联通 RSet记录的外部引用作为扫描存活对象的入口</li><li>第二阶段, 处理 dirty card queue 中的 card, 更新 RSet，完成后 RSet 可以准确反应老年代对所在的内存分段中对象的引用</li><li>第三阶段, 处理 RSet, 识别被老年代对象指向的 Eden 区中的对象, 这些被指向 Eden 中的对象认为是存活的对象</li><li>第四阶段, 复制 对象 (复制算法), 对象树被遍历, Eden 区 region 中存活的对象会被复制到 Survivor 区中的 Region, Survivor Region 中存活的对象如果年龄未达到阈值, 年龄+1, 达到阈值的会被复制到 Old Region, 如果 Survivor 的空间不够用, Eden中部分数据会直接晋升到老年代</li><li>第五阶段, 处理 引用, 处理 Soft、Weak、Phantom、Final、JNI Weak 等应用，最终 Eden 区的数据为空, 这些空的 region 将会等待对象分配, GC 停止工作，目标内存中的对象也是连续的，没有内存碎片</li></ul></blockquote></li></ul></li><li><p>老年代并发标记</p><p>当堆空间的内存使用达到阈值(默认 45%)开始老年代并发标记过程。</p><ul><li>初始标记阶段：标记 GC Roots 直接可达对象，也就是直接引用关系对象，会发生 STW，但是暂停时间很短，触发一次 Young GC</li><li>根区域的扫描 (Root Region Scanning): G1 扫描 Survivor区直接可达的老年代区域对象，并标记为被引用的对象(在YoungGC之前完成，确保 YoungGC操作 Survivor区对象之后)</li><li>并发标记( Concurrent Marking): 在整个堆中进行并发标记，此过程可能会被 Young GC 打断，在并发标记阶段，若发现某些 region 的所有的对象都是垃圾，那么这个 region 就会被立即回收, 同时在标记过程中，会计算每个 region 的对象活性(该 region 存活对象的比例, G1 垃圾回收的时候并不是所有的 region 都会参与回收的, 根据回收的价值高低来优先回收价值较高的 region )</li><li>再次标记: 为了修正并发标记过程，程序线程继续并发指向产生的新的操作,这是修正上一次标记的结果, 增量补偿标记, 会出现 STW， G1采用的是 比CMS更快的初始快照算法 snapsho-at-the-beginning SATB</li><li>独占清理: 计算各个 region 的存活对象 和 GC 回收比例, 并进行排序(回收价值的高低排序), 识别可以混合回收的区域</li><li>并发清理阶段: 识别并且完成空闲的区域</li></ul></li><li><p>混合回收</p><ul><li>回收包含了年轻代和老年代</li><li>标记完成后马上开始垃圾回收, G1 从老年代移动存活的对象到空闲区域，这些空闲区域变成老年代的 region。当越来越多的对象晋升到老年代的 region 时候，为了避免内存耗尽，会触发混合垃圾收集 Mixed GC, 针对的是回收整个 Young region 和 一部分 Old region<blockquote><ul><li>并发标记结束之后, 老年代中能够完全确认为垃圾的 region 中的内存分段被回收，部分为垃圾的 region 中的内存分段也被计算出来。默认情况下，这些老年代的内存分段会被分8次回收</li><li>混合回收的回收集包括 1/8 的老年代的内存分段,、Eden 区内存分段、Survivor区内存分段</li><li>由于老年代的内存分段默认分 8 次回收(当然可以通过参数更改), G1 会优先回收垃圾较多的内存分段, 垃圾占用内存分段比例高的会优先被回收</li></ul></blockquote></li></ul></li><li><p>必要情况下(对象分配速度大于回收速度) Full GC 触发</p></li></ul><h2 id=垃圾收集器的特点>垃圾收集器的特点</h2><table><thead><tr><th style=text-align:left>垃圾收集器</th><th style=text-align:left>分类</th><th style=text-align:left>作用位置</th><th style=text-align:left>使用算法</th><th style=text-align:left>特点</th><th style=text-align:left>适用场景</th></tr></thead><tbody><tr><td style=text-align:left>Serial</td><td style=text-align:left>串行</td><td style=text-align:left>新生代</td><td style=text-align:left>复制算法</td><td style=text-align:left>响应速度优先</td><td style=text-align:left>适合单 CPU 环境 client 模式</td></tr><tr><td style=text-align:left>ParNew</td><td style=text-align:left>并行</td><td style=text-align:left>新生代</td><td style=text-align:left>复制算法</td><td style=text-align:left>响应速度优先</td><td style=text-align:left>适合多 CPU 环境 Server 模式 与 CMS 配合使用</td></tr><tr><td style=text-align:left>Parallel</td><td style=text-align:left>并行</td><td style=text-align:left>新生代</td><td style=text-align:left>复制算法</td><td style=text-align:left>吞吐量优先</td><td style=text-align:left>适用于后台运算而不需要太多交互的场景</td></tr><tr><td style=text-align:left>Serial Old</td><td style=text-align:left>串行</td><td style=text-align:left>老年代</td><td style=text-align:left>标记压缩算法</td><td style=text-align:left>响应速度优先</td><td style=text-align:left>适合单 CPU 环境 client 模式</td></tr><tr><td style=text-align:left>Parallel Old</td><td style=text-align:left>并行</td><td style=text-align:left>老年代</td><td style=text-align:left>标记压缩算法</td><td style=text-align:left>吞吐量优先</td><td style=text-align:left>适用于后台运输而不需要太多交互的场景</td></tr><tr><td style=text-align:left>CMS</td><td style=text-align:left>并发</td><td style=text-align:left>老年代</td><td style=text-align:left>标记清除算法</td><td style=text-align:left>响应速度优先</td><td style=text-align:left>适合互联网或 B/S业务</td></tr><tr><td style=text-align:left>G1</td><td style=text-align:left>并发、并行</td><td style=text-align:left>新生代、老年代</td><td style=text-align:left>标记压缩算法、复制算法</td><td style=text-align:left>响应速度优先</td><td style=text-align:left>面向服务器端应用</td></tr></tbody></table></div></article><div class=blog-post-comments><div id=disqus_thread><script type=text/javascript>(function(){var t,e=document.createElement('script');e.type='text/javascript',e.async=!0,t='pinkhello',e.src='//'+t+'.disqus.com/embed.js',(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/categories>Category</a></li><li><a href=/tags>Tag</a></li><li><a href=/index.xml>Rss</a></li><li><a href=/jobs>Job</a></li></ul></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f" aria-label=Facebook><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f&text=JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84JMM" aria-label=Twitter><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f&title=JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84JMM" aria-label=Linkedin><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f&is_video=false&description=JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84JMM" aria-label=Pinterest><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84JMM&body=Check out this article: https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f" aria-label=Email><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f&title=JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84JMM" aria-label=Pocket><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f&title=JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84JMM" aria-label=reddit><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f&name=JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84JMM&description=JVM%20%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%20%e4%bb%8eJVM%e7%9a%84%e5%ae%98%e6%96%b9%e6%96%87%e6%a1%a3%e4%b8%8a%e5%8f%af%e4%bb%a5%e7%9c%8b%e8%a7%81%ef%bc%8cJVM%e7%9a%84%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84%e4%b8%bb%e8%a6%81%e5%8c%85%e5%90%ab%e4%b8%89%e5%9d%97%3a%20%e5%a0%86%e5%86%85%e5%ad%98%e3%80%81%e6%96%b9%e6%b3%95%e5%8c%ba%e3%80%81%e6%a0%88%0a%e5%a0%86%e4%b8%ad%e5%8f%88%e5%88%86%20%e6%96%b0%e7%94%9f%e4%bb%a3%20%e5%92%8c%20%e8%80%81%e5%b9%b4%e4%bb%a3%2c%20%e6%96%b0%e7%94%9f%e4%bb%a3%e5%8c%85%e5%90%ab%20Eden%e7%a9%ba%e9%97%b4%e3%80%81From%20Survivor%e7%a9%ba%e9%97%b4%e3%80%81To%20Survivor%e7%a9%ba%e9%97%b4%ef%bc%8c%e4%b9%9f%e6%98%af%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab%e7%9a%84%e5%8c%ba%e5%9f%9f%0a%e6%96%b9%e6%b3%95%e5%8c%ba%ef%bc%88%e9%9d%9e%e5%a0%86%e5%8c%ba%ef%bc%89%e5%ad%98%e5%82%a8%e7%9a%84%20%e7%b1%bb%e4%bf%a1%e6%81%af%e3%80%81%e5%b8%b8%e9%87%8f%e3%80%81%e9%9d%99%e6%80%81%e5%8f%98%e9%87%8f%e7%ad%89%e6%95%b0%e6%8d%ae%ef%bc%8c%e6%98%af%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab%e7%9a%84%e5%8c%ba%e5%9f%9f%ef%bc%8c%0a%e6%a0%88%20%e5%88%86%e4%b8%ba%20%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95%e6%a0%88%20%e5%92%8c%20JVM%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88%ef%bc%8c%e8%bf%98%e6%9c%89%e4%b8%aa%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8%20%e8%bf%99%e4%b8%89%e4%b8%aa%e9%83%bd%e6%98%af%e7%ba%bf%e7%a8%8b%e7%a7%81%e6%9c%89%e7%9a%84%0aJava%20Heap%20Java%20Heap%20%e6%98%af%20JVM%20%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%ae%a1%e7%90%86%e7%9a%84%e5%86%85%e5%ad%98%e6%9c%80%e5%a4%a7%e7%9a%84%e4%b8%80%e5%9d%97%ef%bc%8cJava%20Heap%20%e8%a2%ab%e6%89%80%e6%9c%89%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab%e7%9a%84%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%ef%bc%8c%e5%87%a0%e4%b9%8e%e6%89%80%e6%9c%89%e7%9a%84%e5%af%b9%e8%b1%a1%e9%83%bd%e5%9c%a8%e8%bf%99%e9%87%8c%e5%88%86%e9%85%8d%ef%bc%8c%e4%b9%9f%e6%98%af%20GC%20%e7%ae%a1%e7%90%86%e7%9a%84%e4%b8%bb%e8%a6%81%e5%8c%ba%e5%9f%9f%20Java%20Heap%20%e6%98%af%e5%9c%a8%e7%89%a9%e7%90%86%e4%b8%8a%e4%b8%8d%e8%bf%9e%e7%bb%ad%e7%9a%84%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%ef%bc%8c%e5%8f%aa%e8%a6%81%e9%80%bb%e8%be%91%e4%b8%8a%e8%bf%9e%e7%bb%ad%e5%8d%b3%e5%8f%af%e3%80%82%0aMethod%20Area%20Method%20Area%ef%bc%88%e9%9d%9e%e5%a0%86%ef%bc%89%20%e5%92%8c%20Java%20Heap%20%e4%b8%80%e6%a0%b7%ef%bc%8c%e6%98%af%f0%9f%a7%8d%e5%90%84%e4%b8%aa%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab%e7%9a%84%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%ef%bc%8c%e7%94%a8%e4%ba%8e%e5%ad%98%e5%82%a8%e5%b7%b2%e7%bb%8f%e8%a2%ab%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%8a%a0%e8%bd%bd%e7%9a%84%20%e7%b1%bb%e4%bf%a1%e6%81%af%e3%80%81%e5%b8%b8%e9%87%8f%e3%80%81%e9%9d%99%e6%80%81%e5%8f%98%e9%87%8f%e3%80%81%e5%8d%b3%e4%bd%bf%e7%bc%96%e8%af%91%e5%99%a8%e7%bc%96%e8%af%91%e7%9a%84%e4%bb%a3%e7%a0%81%e7%ad%89%e7%ad%89%0aProgram%20Counter%20Register%20Program%20Counter%20Register%20%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8%ef%bc%8c%e8%be%83%e5%b0%8f%e7%9a%84%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%ef%bc%8c%e6%98%af%e5%bd%93%e5%89%8d%e7%ba%bf%e7%a8%8b%e9%94%81%e6%89%a7%e8%a1%8c%e7%9a%84%e5%ad%97%e8%8a%82%e7%a0%81%e7%9a%84%e8%a1%8c%e5%8f%b7%e6%8c%87%e7%a4%ba%e5%99%a8%ef%bc%88%e5%94%af%e4%b8%80%e4%b8%80%e4%b8%aa%e6%b2%a1%e6%9c%89OOM%e7%9a%84%e5%8c%ba%e5%9f%9f%ef%bc%89%0aJVM%20Stacks%20JVM%20Stacks%20%e4%b9%9f%e6%98%af%e7%ba%bf%e7%a8%8b%e7%a7%81%e6%9c%89%e7%9a%84%ef%bc%8c%e5%ae%83%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%92%8c%e7%ba%bf%e7%a8%8b%e7%9b%b8%e5%90%8c%ef%bc%8c%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88%e6%8f%8f%e8%bf%b0%e7%9a%84%20Java%20%e6%96%b9%e6%b3%95%e6%89%a7%e8%a1%8c%e7%9a%84%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%ef%bc%9a%20%e5%88%9b%e5%bb%ba%e6%a0%88%e5%b8%a7%20Stack%20frame%20%e7%94%a8%e4%ba%8e%e5%ad%98%e5%82%a8%20%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e8%a1%a8%e3%80%81%e6%93%8d%e4%bd%9c%e6%a0%88%e3%80%81%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e3%80%81%e6%96%b9%e6%b3%95%e5%87%ba%e5%8f%a3%20%e7%ad%89%e4%bf%a1%e6%81%af%20%e6%af%8f%e6%ac%a1%e6%96%b9%e6%b3%95%e8%a2%ab%e8%b0%83%e7%94%a8%e7%9b%b4%e8%87%b3%e5%ae%8c%e6%88%90%ef%bc%8c%e9%83%bd%e5%af%b9%e5%ba%94%e7%9d%80%e4%b8%80%e4%b8%aa%e6%a0%88%e5%b8%a7%e5%9c%a8%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88%e4%b8%ad%e7%9a%84%e5%85%a5%e6%a0%88%e5%92%8c%e5%87%ba%e6%a0%88%e8%bf%87%e7%a8%8b%e3%80%82%0aJVM%20%e4%b8%a4%e7%a7%8d%e5%bc%82%e5%b8%b8%ef%bc%9a%0a%e7%ba%bf%e7%a8%8b%e8%af%b7%e6%b1%82%e6%a0%88%e6%b7%b1%e5%ba%a6%e5%a4%a7%e4%ba%8e%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%85%81%e8%ae%b8%e7%9a%84%e6%b7%b1%e5%ba%a6%20StackOverflowError%0aJVM%e6%a0%88%e4%b8%80%e8%88%ac%e5%8a%a8%e6%80%81%e6%89%a9%e5%b1%95%e7%9a%84%ef%bc%8c%e5%a6%82%e6%9e%9c%e6%97%a0%e6%b3%95%e7%94%b3%e8%af%b7%e8%b6%b3%e5%a4%9f%e7%9a%84%e5%86%85%e5%ad%98%ef%bc%8c%e4%bc%9a%e6%8a%9b%20OutOfMemoryError" aria-label=Tumblr><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fpinkhello.cc%2fposts%2fjvm%25E5%2586%2585%25E5%25AD%2598%25E7%25BB%2593%25E6%259E%2584jmm%2f&t=JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84JMM" aria-label="Hacker News"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu-toggle class=icon href=# onclick="return $('#nav-footer').toggle(),!1" aria-label=Menu><i class="fas fa-bars fa-lg" aria-hidden=true></i> Menu</a>
<a id=share-toggle class=icon href=# onclick="return $('#share-footer').toggle(),!1" aria-label=Share><i class="fas fa-share-alt fa-lg" aria-hidden=true></i> share</a>
<a id=top style=display:none class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast')" aria-label="Top of Page"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i> Top</a></div></div></div><footer id=footer><div class=footer-left>Copyright &copy; 2022 pinkhello</div><div class=footer-right><nav><ul><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/categories>Category</a></li><li><a href=/tags>Tag</a></li><li><a href=/index.xml>Rss</a></li><li><a href=/jobs>Job</a></li></ul></nav></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
<script src=/js/code-copy.js></script>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></html>