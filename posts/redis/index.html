<!doctype html><html lang=en-us><head><link rel=preload href=/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><script type=text/javascript src=https://latest.cactus.chat/cactus.js></script>
<link rel=stylesheet href=https://latest.cactus.chat/style.css type=text/css><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>重学Redis | pinkhello</title><link rel=canonical href=https://pinkhello.cc/posts/redis/><meta name=description content="👷Hey! 我是 **pinkhello**，💻 一名后端程序员。**重要提示**: 在您阅读文章并评论之前，请先认真阅读[**评论承诺**](http://pinkhello.cc/promise)。"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="重学Redis"><meta property="og:description" content="重学Redis"><meta property="og:type" content="article"><meta property="og:url" content="https://pinkhello.cc/posts/redis/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-29T15:15:21+08:00"><meta property="article:modified_time" content="2022-08-29T15:15:21+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="重学Redis"><meta name=twitter:description content="重学Redis"><link rel=stylesheet href=https://pinkhello.cc/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="><link rel=stylesheet href=https://pinkhello.cc/css/pinkhello.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://pinkhello.cc/images/favicon.ico><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-M2FXWC325L","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class="max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a>
<a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a>
<a id=top-icon-tablet href=# onclick='$("html, body").animate({scrollTop:0},"fast")' style=display:none aria-label="Top of Page"><i class="fas fa-chevron-up fa-lg"></i></a>
<span id=menu><span id=nav><ul><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/categories>Category</a></li><li><a href=/tags>Tag</a></li><li><a href=/index.xml>Rss</a></li><li><a href=/jobs>Job</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=https://pinkhello.cc/posts/%E5%85%B3%E4%BA%8E%E5%9B%A2%E9%98%9F%E7%9A%84%E6%80%9D%E8%80%83/ aria-label=Previous><i class="fas fa-chevron-left" aria-hidden=true onmouseover='$("#i-prev").toggle()' onmouseout='$("#i-prev").toggle()'></i></a></li><li><a class=icon href=# onclick='$("html, body").animate({scrollTop:0},"fast")' aria-label="Top of Page"><i class="fas fa-chevron-up" aria-hidden=true onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class=icon href=# aria-label=Share><i class="fas fa-share-alt" aria-hidden=true onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f" aria-label=Facebook><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f&text=%e9%87%8d%e5%ad%a6Redis" aria-label=Twitter><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f&title=%e9%87%8d%e5%ad%a6Redis" aria-label=Linkedin><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f&is_video=false&description=%e9%87%8d%e5%ad%a6Redis" aria-label=Pinterest><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=%e9%87%8d%e5%ad%a6Redis&body=Check out this article: https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f" aria-label=Email><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f&title=%e9%87%8d%e5%ad%a6Redis" aria-label=Pocket><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f&title=%e9%87%8d%e5%ad%a6Redis" aria-label=reddit><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f&name=%e9%87%8d%e5%ad%a6Redis&description=%e9%87%8d%e5%ad%a6Redis" aria-label=Tumblr><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f&t=%e9%87%8d%e5%ad%a6Redis" aria-label="Hacker News"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">重学Redis</h1><div class=meta><div class=postdate><time datetime="2022-08-29 15:15:21 +0800 +0800" itemprop=datePublished>2022-08-29</time></div><div class=article-category><i class="fas fa-archive"></i>
<a class=category-link href=/categories/tech>Tech</a></div><div class=article-tag><i class="fas fa-tag"></i>
<a class=tag-link href=/tags/redis rel=tag>redis</a></div></div></header><div id=toc><nav id=TableOfContents><ul><li><a href=#redis>redis</a></li><li><a href=#redis-数据类型>redis 数据类型</a></li><li><a href=#redis-key-的推荐规则>redis key 的推荐规则</a></li><li><a href=#string>String</a></li><li><a href=#lists>Lists</a></li><li><a href=#sets>Sets</a></li><li><a href=#sorted-sets>Sorted Sets</a></li><li><a href=#hashes>Hashes</a></li><li><a href=#streams>Streams</a></li><li><a href=#geospatial>Geospatial</a></li><li><a href=#hyperloglog>HyperLogLog</a></li><li><a href=#bitmaps>BitMaps</a></li><li><a href=#bitfields>Bitfields</a></li><li><a href=#client-side-caching>Client-side caching</a></li><li><a href=#key-eviction>Key eviction</a></li><li><a href=#high-availability-sentinelhttpsredisiodocsmanualsentinel>High availability <a href=https://redis.io/docs/manual/sentinel/>Sentinel</a></a></li></ul></nav></div><div class=content itemprop=articleBody><h2 id=redis>redis</h2><p><code>redis</code> 是BSD许可的开源内存数据中间件，可以用作 数据库、缓存、<code>消息Broker</code>、流引擎。</p><h2 id=redis-数据类型>redis 数据类型</h2><p><code>data structures</code>:</p><ul><li><code>strings</code></li><li><code>hashes</code></li><li><code>lists</code></li><li><code>sets</code></li><li><code>sorted sets [range queries]</code></li><li><code>bitmaps</code></li><li><code>hyperloglogs</code></li><li><code>geospatial indexes</code></li><li><code>streams</code></li></ul><h2 id=redis-key-的推荐规则>redis key 的推荐规则</h2><p><code>keys rule</code>:</p><ul><li>不要设置过长的<code>KEY</code></li><li>过短的<code>KEY</code>也不建议</li><li>适中，并且能达意的，考虑用分隔符</li><li>最大的<code>KEY SIZE</code>: <code>512</code>MB.</li></ul><h2 id=string>String</h2><p><code>Redis</code> 存储字符序列、可以是 文本、序列话对象、二进制数组。支持 <code>incr</code> 操作。</p><ul><li><code>SET</code></li><li><code>SETNX</code></li><li><code>GET</code></li><li><code>MEGT</code></li></ul><p>大部分字符串操作都是 <code>O(1)</code>, 但是 <code>SUBSTR</code>、<code>GETRANGE</code>、<code>SETRANGE</code> 可能是 <code>O(n)</code></p><p><code>Redis String</code> 是才赢得 <code>SDS</code> 实现的（<code>Simple dynamic string</code>）</p><p>在执行 <code>set hello helloval</code>后底层是</p><ul><li>那么键的字符串对象，底层创建保存 &lsquo;hello&rsquo; 的<code>SDS</code></li><li>那么值也是字符串对象，底层创建保存字符串的 &lsquo;helloval&rsquo; 的<code>SDS</code></li></ul><p><code>SDS</code> 的结构体</p><pre tabindex=0><code>    struct sdshdr {
        char buf[]; //字节数组，用于保存字符串
        int len;  //记录buf数组中已经使用字节的数量
        int free; //记录buf数组内未使用的字节的数量
    }
</code></pre><ul><li>对比<code>C</code>，有专门的字段记录buf数组的字符串长度和空闲 时间复杂度<code>O(1)</code></li><li>对比<code>C</code>，记录字符串了长度，在进行分配的时候，或修改的时候，杜绝了缓冲区溢出的可能性，在<code>SDS API</code>对<code>SDS</code>进行修改的时候，会先检查空间是否满足修改的需求，不满足的话，会先拓展至执行所需要的大小，再执行修改操作。</li><li>减少字符串修改带来的内存重分配操作， 通过 <code>free</code> 参数记录未使用的空间，这样实现了空间预分配和惰性空间释放策略</li><li>二进制安全。因为有 <code>len</code> 属性，不需要判断字符串确认是否是末尾。可以存储任意结构的二进制数据</li><li>兼容部分C函数</li></ul><h2 id=lists>Lists</h2><p>通过链表实现的、即使有数百万元素，在列表头部或尾部添加新元素的操作都是<code>O(1)</code>: <code>LPUSH</code> 同时向<code>10</code>个元素和<code>100万</code>个元素添加头部元素的速度是相同的。</p><p>最大的长度 <code>2^32 - 1</code></p><ul><li><p>实现 堆栈 或 队列</p></li><li><p>后端分布式系统构建队列使用</p></li><li><p><code>LPUSH</code></p></li><li><p><code>LPOP</code></p></li><li><p><code>LLEN</code></p></li><li><p><code>LMOVE</code></p></li><li><p><code>LTRIM</code></p></li></ul><p>例子</p><ul><li>记录用户发布社交网络的最新更新(<code>LPUSH</code>、<code>LRANGE</code>)</li><li>进程间通讯，生产消费模式，生产者将元素推进入列表中（<code>LPUSH</code>），消费者消费这些元素(<code>RPOP</code>)</li></ul><p>访问其头部或尾部的列表操作是 <code>O(1)</code>，但是操作列表中元素通常是 <code>O(n)</code>, <code>LINDEX</code>、<code>LINSERT</code>、<code>LSET</code></p><h2 id=sets>Sets</h2><p>唯一字符串成员的无序集合。</p><p>最大的长度 <code>2^32 - 1</code></p><ul><li><code>SADD</code></li><li><code>SREM</code></li><li><code>SISMEMBER</code></li><li><code>SINTER</code></li><li><code>SCARD</code></li></ul><p><code>SADD</code>、<code>SREN</code>、<code>SISMEMBER</code> 是 <code>O(1)</code>。 <code>SMEMBERS</code> 在大型集合时候是 <code>O(n)</code>, 替换方案 <code>SSCAN</code></p><h2 id=sorted-sets>Sorted Sets</h2><p>通过相关分数排序的唯一字符串成员集合， 当分数相同的时候，这些字符串按字典顺序排列</p><ul><li><p>排行榜，排序最高分的有序列表</p></li><li><p>速率限制器，通过滑动窗口速率限制器防止更多的API请求</p></li><li><p><code>ZADD</code></p></li><li><p><code>ZRANGE</code></p></li><li><p><code>ZRANK</code></p></li><li><p><code>ZREVRANK</code></p></li></ul><p>大多数集合操作都是 <code>O(log(n))</code>, <code>n</code> 是成员数</p><h2 id=hashes>Hashes</h2><p>通过 键值对 的集合，</p><p>最多存储散列的是 <code>2^32 - 1</code>， 但是往往 值受限于 <code>VM</code> 总内存限制</p><ul><li><code>HSET</code></li><li><code>HGET</code></li><li><code>HMGET</code></li><li><code>HINCRBY</code></li></ul><p>大部分 <code>O(1)</code> ， <code>HKEYS</code>，<code>HVALS</code>、<code>HGETALL</code> 是 <code>O(n)</code>， n是键值对的数量</p><p><code>Hash</code> 是一个很常见的数据结构、<code>Redis</code> 的实现是一个比较经典的方案。 其采用了<code>链式哈希</code>，在不扩容哈希表的前提下，将相同哈希值的数据链起来。 在针对<code>rehash</code> 的上，设计了<code>渐进式rehash设计</code>，缓解了<code>rehash</code>操作带来的额外开销。</p><p><code>链式哈希</code></p><ul><li><code>哈希</code>是将不定长的变成定点长的操作，</li><li>一个最简单的哈希是一个数组，数组的每个元素等于一个<code>哈希桶</code></li><li>会存在多个<code>key</code>哈希完后是同一个值，这个就是<code>哈希冲突</code>。那么解决哈希冲突最简单的方式就是，哈希桶下挂载链表，链表内存储的是值</li></ul><p>往往我们在新开启的<code>哈希桶</code>的时候，因为无法预知数据大小，所以不会一下子开辟很大哈希表。链式哈希带来了问题是</p><ul><li><code>hash碰撞</code>：带来了在单个<code>Hash桶</code>上退化为<code>链表</code>，损失了<code>高性能</code>（ 数组O(1)的时间复杂度 变成了 链表的O(N)的复杂度 ）</li><li><code>无序性</code>：<code>HashMap</code>的<code>Hash桶</code> 数组的顺序与<code>put</code>操作的先后顺序无关</li></ul><p>无序性还好，但是 hash碰撞带来的问题是导致<code>Hash桶</code>的扩容，如果大批量的数据，触发<code>负载因子</code>后触发<code>hash桶</code>的扩容。如果不设计一套扩容方案，会导致要数据分配完毕才进行其他操作，会丧失 redis 的高性能, 所以 Redis 设计了一套 <code>渐进式Rehash</code></p><p><code>渐进式Rehash</code></p><p><code>Redis</code> 默认使用了 <code>两个</code> <code>全局Hash表</code>，先使用的是 <code>Hash表A</code>，此时另外的 <code>Hash表B</code> 并未被分配空间，随着 <code>Hash表A</code> 的数据增多，<code>Hash碰撞</code>越来越多拉低了 <code>redis</code> 的性能，开启 <code>rehash操作</code>：</p><ul><li>给 <code>Hash表B</code> 申请较大的空间，入 <code>Hash表A</code> 的哈希桶数组容量的 <code>2</code> 倍</li><li>将 <code>Hash表A</code> 的元素重新计算 <code>Hash</code> 和 <code>取模</code> 运算，映射到 <code>Hash表B</code> 中</li><li>清理 <code>Hash表A</code></li></ul><p>具体过程是</p><ul><li>从<code>Hash桶</code>数组 的第一个 节点开始，每次处理客户端一个请求，想<code>Hash表B</code>中<code>Copy</code>一组Hash桶的数据。直到所有的节点数据 <code>COPY</code>完成</li></ul><p><img src=/redis/%E6%B8%90%E8%BF%9B%E5%BC%8Frehash.jpeg alt=渐进式rehash></p><p><code>rehash</code> 和 <code>hashmap</code> 的扩容区别</p><ul><li>rehash 扩容 两个 hash表，hash表B 的扩容是 Hash表A 的 2倍，扩容过程中新加入的元素直接添加到 hash表B</li><li>hashmap 的 resize，</li></ul><h2 id=streams>Streams</h2><p><code>Stream</code> 是一种数据结构、作用类似于 附加日志，可以使用 Stream 实时记录 和 同步事件。</p><p><code>Redis</code> 为 <code>每个Stream</code> 条目生成一个唯一的ID，可以使用这个ID进行检索和关联条目</p><ul><li><p>事件溯源</p></li><li><p>设备监控</p></li><li><p>通知</p></li><li><p><code>XADD</code> 向 <code>Stream</code> 添加条目</p></li><li><p><code>XREAD</code> 读取或者多个条目，从给定位置开始</p></li><li><p><code>XRANGE</code> 返回两个<code>ID</code>之间的条目范围</p></li><li><p><code>XLEN</code> 返回 <code>Stream</code> 的长度</p></li></ul><p>向 <code>Stream</code> 添加是 <code>O(1)</code>, 访问任何单个条目都是 <code>O(n)</code>, <code>N</code>x是 <code>ID</code> 的长度</p><h2 id=geospatial>Geospatial</h2><p>地理空间坐标用来搜寻给定半径 或 边界范围 的附近点的。</p><ul><li><code>GEOADD</code> 将位置添加到给定的地理空间索引，经度位于纬度之前</li><li><code>GEOSEARCH</code> 返回具有给定半径或边界框的位置</li></ul><h2 id=hyperloglog>HyperLogLog</h2><p><code>HyperLogLog</code> 是一种估计集合基数的数据结构、是一种概率数据结构。以准确性换取了空间利用率。</p><p><code>HyperLogLog</code> 可以估计具有多达 <code>2^64</code> 个成员的基数</p><ul><li><code>PFADD</code> 将元素添加到 <code>HyperLogLog</code></li><li><code>PFCOUNT</code> 返回集合中元素的估计值</li><li><code>PFMERGE</code> 将两个或者多个 <code>HyperLogLog</code> 合并成一个</li></ul><p><code>PFADD</code>、<code>PFCOUNT</code> 都是恒定时间和空间完成的 ，合并 <code>HLL</code> 是 <code>O(n)</code>, <code>n</code> 是草图的数量</p><h2 id=bitmaps>BitMaps</h2><p><code>bitmaps</code> 是字符串类型数据的扩展，可以将字符串视为响亮，可以对一个或者多个字符串执行按位运算。</p><ul><li><p>对于 集合的成员对应与 <code>0-N</code> 的请客，有效的集合</p></li><li><p>对象权限、每个位代表一个特定权限。</p></li><li><p><code>SETBIT</code> 将提供偏移量设置为 <code>0</code> 或 <code>1</code></p></li><li><p><code>GETBIT</code> 返回给定偏移量的位值</p></li><li><p><code>BITOP</code> 允许对一个或多个字符串执行按位运算</p></li></ul><p><code>SETBIT</code> 、<code>GETBIT</code> 都是 <code>O(1)</code>, <code>BITOP</code> 是 <code>O(n)</code>, <code>n</code> 是比较中最长字符串的长度</p><h2 id=bitfields>Bitfields</h2><h2 id=client-side-caching>Client-side caching</h2><p>客户边缘缓存技术是一种提高性能的服务技术。顾名思义，是借助客户端的可用内存去存储部分从数据库端获取到数据子集。</p><p>特点</p><ul><li>数据可以以非常小的延迟可用</li><li>减少数据库的查询，提高性能</li></ul><h2 id=key-eviction>Key eviction</h2><p><code>maxmemory</code> 配置的是为数据集使用制定数量的内存，设置为 0 ,没有内存限制（64位）【32位的是默认的3GB】</p><ul><li><code>noeviction</code>：达到内存限制，怒不保存新的</li><li><code>allkeys-lru</code>：保留最近使用的，删除最近最少使用的</li><li><code>allkeys-lfu</code>：保存经常使用的，删除最少使用的 LFU</li><li><code>volatile-lru</code>：删除 expire 为 true，最近最少使用的</li><li><code>volatile-lfu</code>：删除 expire 为 true 的最不常用的</li><li><code>allkeys-random</code>：随机删除</li><li><code>volatile-random</code>：随机删除 expire 为 true</li><li><code>volatile-ttl</code>: 删除 expire 字段为 true 且 最短剩余生存时间（TTL）</li></ul><p>淘汰驱逐的过程:</p><ul><li>客户端运行新命令、服务端添加新的数据。</li><li><code>Redis</code> 检查内存使用情况、如果大于 <code>maxmemory</code> 限制, 它回根据策略驱逐</li><li>执行命令，添加数据</li></ul><h2 id=high-availability-sentinelhttpsredisiodocsmanualsentinel>High availability <a href=https://redis.io/docs/manual/sentinel/>Sentinel</a></h2><p><code>Sentinel</code> 是在不实用 <code>Cluster</code> 提高可用性的。包含的功能有</p><ul><li>监控：<code>sentinel</code>节点会定期检测 <code>redis</code> 数据节点（主从）、其余 <code>Sentinel</code> 节点是否可达</li><li>通知： <code>sentinel</code>节点会将故障转移的结构通知给应用方</li><li>自动故障转移： 主节点不可用，从节点晋升为主节点并维续后续正巧的主从关系</li><li>配置提供者： <code>Redis Sentinel</code>，客户端在初始化的时候连接的是 <code>Sentinel</code> 节点的集合，从中获取主节点的信息</li></ul><h1 id=keyspace-notifications>keyspace notifications</h1><p><code>Keyspace</code> 通知允许客户端订阅 <code>Pub/Sub</code> 频道，以便接收以某种方式影响 <code>Redis</code> 数据集的事件。</p><ul><li>All the commands affecting a given key.</li><li>All the keys receiving an LPUSH operation.</li><li>All the keys expiring in the database 0.</li></ul><p>键空间通知是通过为 影响数据空间的每个操作发送两种不同类型的事件实现的。</p><h1 id=persistence>Persistence</h1><p><code>redis</code> 如何将数据写入磁盘的，<code>append-only files</code>、<code>snapshots</code>！</p><p>持久性是将数据写入持久存储设备。</p><ul><li>RDB(Redis Database) 以指定时间间隔执行数据集的时间点快照</li><li>AOF(Append Only File): AOF 持久化记录服务器接受的每个写操作，在服务器启动的时候，再次进行回放，重建原始数据集。 指令的写入是与Redis协议相同，以追加的方式记录。</li><li>No persistence</li><li>RDB + AOF 可以在同一个实例中结合使用 <code>AOF</code> + <code>RDB</code>, 这种情况下，数据最完整。</li></ul><p><code>RDB</code> 优势</p><ul><li><code>RDB</code> 是 <code>redis</code> 数据非常紧凑的单元时间点表示的，<code>RDB</code>文件非常适合备份， 可以在最近24小时内每小时归档一次<code>RDB</code>文件，并在30天每天保存一份<code>RDB</code>文件。可以多个版本的</li><li><code>RDB</code> 非常适合灾难性恢复（他其实就是一个加密的压缩文件）</li><li><code>RDB</code> 最大化的提高性能，</li><li><code>RDB</code> 在大数据集的情况下重启比AOF快</li><li>在同步副本上， <code>RDB</code> 在重启 和 故障转移的情况下支持 部分同步</li></ul><p><code>RDB</code> 缺点</p><ul><li>在要求对数据丢失的可能性最低的情况下，<code>RDB</code>并不好。因为是定期备份，在这个单位时间内停止工作的会，导致丢失最新的数据</li><li><code>RDB</code> 需要经常 <code>fork()</code> ，在子进程持久化数据存盘的时候。<code>Fork</code>操作可能很耗时，同时大数据集的时候会影响<code>CPU性能</code>。<code>AOF</code> 也需要 <code>fork</code> 但是频率很低。</li></ul><p><code>AOF</code> 优势</p><ul><li>更多的 <code>fsync</code> 策略： 从不 <code>fsync</code>、每秒 <code>fsync</code>, 每次查询时 <code>fsync</code>， <code>fsync</code> 是后台线程执行，</li><li><code>AOF</code> 日志是 追加日志，因此没有寻址问题，也不会在断电的时候出现损坏问题，即使某个原因日志写一半命令结束，也可以使用 <code>redis-check-aof</code> 工具恢复它</li><li><code>AOF</code> 变得很大的时候，<code>redis</code> 可以在后台自动重写 <code>AOF</code>。重写是完全安全的，因为当<code>redis</code>继续追加旧文件的时候，会使用创建当前的数据集做少的操作集重新生成一个全新的文件，一旦文件准备完毕，<code>redis</code> 就会切换两者并追加哦到新的文件</li><li><code>AOF</code> 操作日志，是易于理解和解析的。可以轻松的导出 <code>AOF</code> 文件</li></ul><p><code>AOF</code> 缺点</p><ul><li><code>AOF</code> 文件通常比相同的数据集大小的 <code>RDB</code> 文件大</li><li>根据确定的 <code>fsync</code> 策略，<code>AOF</code> 可能比 <code>RDB</code> 慢，</li><li><code>redis &lt; 7.0</code> 在重写期间对数据库的写入，<code>AOF</code> 会使用大量的内存（当前的写入被缓冲在内存，到最后写入）</li><li><code>redis &lt; 7.0</code> 重写期间到达的写入命令会写入磁盘两次</li><li><code>redis &lt; 7.0</code> <code>Redis</code> 可以在重写结束时候，冻结写入并将这些写入命令同步到新的 <code>AOF</code> 文件</li></ul><h1 id=pubsub>Pub/Sub</h1><p><code>7.0</code> 之后 引入了 <code>Sharded Pub/Sub</code>, 在之前的版本，对于集群的 <code>channel</code> 不被当成数据处理，导致了就不回参与 <code>hash</code>计算，无法按 <code>slot</code> 分发到节点，所以在 7.0之前 集群模式下的 <code>redis</code> 对于 <code>pub/sub</code> 是采用广播的方式，这会带来广播风暴的问题。
假设集群 100 个节点，用户在对 <code>节点1</code> 的某个 <code>channel</code> 进行 <code>publish</code> 发布消息，该节点需要将消息广播给其他 <code>99 个节点</code>，如果有的节点只有少量订阅，且绝大部分消息对其来说是无效的。这对 CPU 和 网络都是开销。
而 <code>Shared pub/sub</code> 就是解决该问题， 会把 <code>channel</code> 按 分片来进行分发，一个分片节点只负责处理属于自己的 <code>channel</code> 而不进行广播</p><h1 id=replication>Replication</h1><p><code>replication</code> 是 提供 支持高可用性 和 故障转移的根本。</p><ul><li><code>Master</code> 和 <code>Replica</code> 连接良好时候，<code>Master</code> 通过发送命令数据集来对副本进行更新，包含了写入、过期、驱逐、更改等任何操作</li><li>当 <code>Master</code> 和 <code>Replica</code> 连接中端时候，由于 网络问题 或者 <code>Master</code> 和 <code>Replica</code> 之间检测超时，<code>Replica</code> 会重连、在重连成功后获取断开连接期间错过的命令流。</li><li>当 <code>Replica</code> 确实无法重新同步是，<code>Replica</code> 将采用备用方案，请求全部重新同步，这边 <code>Master</code> 需要创建一个所有数据的快照，将其发送到 <code>Replica</code>，并随着 数据的变化继续发送命令流</li></ul><p><code>Redis</code> 默认采用的 异步复制。异步复制的特点：</p><ul><li><code>Redis</code> 是异步复制，异步复制的是 <code>Master acknowledges</code> 的数据</li><li>一个 <code>Master</code> 允许多个 <code>Replicas</code></li><li><code>Replica</code> 能接受其他 <code>Replica</code> 的连接，除了多个 <code>Replica</code> 连接 同一个 <code>Master</code> 外，<code>Replica</code> 还可以类似级联的结构连接到其他副本</li><li><code>Redis</code> 复制在 <code>Master</code> 是非阻塞的，当一个或多个 <code>Replica</code> 执行 同步 或 部分重新同步的时候，<code>主Master</code> 将继续处理查询。</li><li><code>Replica</code> 在 复制的绝大部分都是非阻塞的，</li><li>复制 可以用于拓展 <code>redis</code> 的扩展性，也可以用于 复制只读查询的副本</li><li>复制 可以 避免 让 <code>Master</code> 将完整的数据写入磁盘</li></ul><h1 id=redis-复制>redis 复制</h1><p>复制的流程：</p><ul><li><code>Master实例</code> 都有一个 <code>复制ID</code>（一串大的随机字符串），标记数据集的，还有一个 <code>offset</code>（它随着要发送给副本的数据流的字节增加），即使没有实际联结的副本， offset 也会增加。 也技术说 <code>Replocation ID, Offset</code> 是标记着数据集合的准确版本。</li><li>当 副本实例 连接 <code>Master</code> 时候，使用 <code>PYSNC</code> 命令发送 他们保存的 <code>旧主服务器</code> <code>复制ID</code> 和 目前他们自己处理的 <code>offset</code>。 这样 <code>master</code> 可以只发送所需要的增量部分</li><li>如果 <code>主Master</code> 的缓冲区没有足够的数据堆积、或者副本饮用的不是已知的 <code>复制ID</code> 的 历史记录，则会触发完全同步。这样副本集合将会获得完整的数据副本。</li></ul><p>完全同步的工作模式：</p><ul><li><code>Master</code> 后台开启生成 <code>RDB文件</code>，并同时缓冲客户端接受的新的写命令</li><li>后台保存完成后，<code>Master</code> 将 <code>RDB文件</code> 传输到 <code>replica</code>， <code>replica</code> 将其保存在磁盘上，然后加载到内存中。</li><li>后续 <code>Master</code> 将所有缓冲的命令 发送到 <code>replica</code>， <code>Replica</code> 执行这个命令流完成。</li></ul><p>复制ID</p><p>如果两个实例具有相同的 <code>复制ID</code> 和 <code>复制偏移量(offset)</code>, 则它们具有完全相同的数据。但是实际上 实例 上有两个 <code>复制ID</code> ： <code>主ID</code> <code>辅助ID</code></p><p><code>Redis</code> 实例为什么会有两个 <code>复制ID</code>，因为 <code>副本</code> 升级为 <code>Master</code>。 故障转移后， 升级的副本仍需要记住它过去的 <code>复制ID</code>，因为这样的 <code>复制ID</code> 是以前的主副本，当其他副本与新的 <code>master</code> 同步时候，他们将尝试使用 <code>旧的Master</code> <code>复制ID</code> 执行部分重新同步。</p><p>当副本升级为 <code>Master</code> 的时候，将把其 <code>辅助ID</code> 设置成 <code>主ID</code>，并记录 <code>发生ID切换的偏移量</code> 是多少。然后，生成一个新的随机 <code>复制ID</code>，用于记录新的开始 。</p></div></article><div class=blog-post-comments><div id=disqus_thread><script type=text/javascript>(function(){var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="pinkhello",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/categories>Category</a></li><li><a href=/tags>Tag</a></li><li><a href=/index.xml>Rss</a></li><li><a href=/jobs>Job</a></li></ul></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f" aria-label=Facebook><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f&text=%e9%87%8d%e5%ad%a6Redis" aria-label=Twitter><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f&title=%e9%87%8d%e5%ad%a6Redis" aria-label=Linkedin><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f&is_video=false&description=%e9%87%8d%e5%ad%a6Redis" aria-label=Pinterest><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=%e9%87%8d%e5%ad%a6Redis&body=Check out this article: https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f" aria-label=Email><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f&title=%e9%87%8d%e5%ad%a6Redis" aria-label=Pocket><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f&title=%e9%87%8d%e5%ad%a6Redis" aria-label=reddit><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f&name=%e9%87%8d%e5%ad%a6Redis&description=%e9%87%8d%e5%ad%a6Redis" aria-label=Tumblr><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fpinkhello.cc%2fposts%2fredis%2f&t=%e9%87%8d%e5%ad%a6Redis" aria-label="Hacker News"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu-toggle class=icon href=# onclick='return $("#nav-footer").toggle(),!1' aria-label=Menu><i class="fas fa-bars fa-lg" aria-hidden=true></i> Menu</a>
<a id=share-toggle class=icon href=# onclick='return $("#share-footer").toggle(),!1' aria-label=Share><i class="fas fa-share-alt fa-lg" aria-hidden=true></i> share</a>
<a id=top style=display:none class=icon href=# onclick='$("html, body").animate({scrollTop:0},"fast")' aria-label="Top of Page"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i> Top</a></div></div></div><footer id=footer><div class=footer-left>Copyright &copy; 2022 pinkhello</div><div class=footer-right><nav><ul><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/categories>Category</a></li><li><a href=/tags>Tag</a></li><li><a href=/index.xml>Rss</a></li><li><a href=/jobs>Job</a></li></ul></nav></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
<script src=/js/code-copy.js></script>
<script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></html>